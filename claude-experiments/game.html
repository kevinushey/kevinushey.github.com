<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Station Escape</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            background: #050810;
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        #game {
            display: block;
            cursor: none;
        }
        #minimap {
            position: absolute;
            top: 10px;
            right: 10px;
            border: 2px solid #2a4060;
            box-shadow: 0 0 10px rgba(0, 150, 200, 0.3);
        }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #5a8aaa;
            font-size: 12px;
            text-shadow: 0 0 5px rgba(0, 150, 200, 0.3);
        }
        /* Touch controls */
        #touch-controls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            pointer-events: none;
            z-index: 100;
            background: rgba(5, 8, 16, 0.95);
            border-top: 2px solid #2a4060;
        }
        .touch-btn {
            position: absolute;
            background: rgba(0, 150, 200, 0.3);
            border: 2px solid rgba(0, 200, 255, 0.5);
            border-radius: 50%;
            color: #0cf;
            font-family: monospace;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        .touch-btn:active {
            background: rgba(0, 200, 255, 0.5);
        }
        #joystick-zone {
            position: absolute;
            bottom: 10%;
            left: 5%;
            width: 35%;
            max-width: 120px;
            aspect-ratio: 1;
            background: rgba(0, 100, 150, 0.2);
            border: 2px solid rgba(0, 200, 255, 0.3);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
        }
        #joystick-knob {
            position: absolute;
            width: 50%;
            height: 50%;
            background: rgba(0, 200, 255, 0.4);
            border: 2px solid rgba(0, 255, 255, 0.6);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #btn-attack {
            bottom: 10%;
            right: 5%;
            width: 25%;
            max-width: 80px;
            aspect-ratio: 1;
            font-size: 12px;
        }
        #btn-door {
            bottom: 10%;
            right: calc(5% + 90px);
            width: 18%;
            max-width: 55px;
            aspect-ratio: 1;
            font-size: 10px;
        }
        #btn-weapon1 {
            bottom: 55%;
            left: calc(50% - 60px);
            width: 15%;
            max-width: 45px;
            aspect-ratio: 1;
            font-size: 10px;
        }
        #btn-weapon2 {
            bottom: 55%;
            left: calc(50% + 15px);
            width: 15%;
            max-width: 45px;
            aspect-ratio: 1;
            font-size: 10px;
        }
        #look-zone {
            position: absolute;
            top: 0;
            left: 30%;
            width: 40%;
            height: 100%;
            pointer-events: auto;
            touch-action: none;
        }
        @media (pointer: coarse), (max-width: 1024px) {
            #touch-controls { display: block; }
            #instructions { display: none; }
            #crosshair { display: none; }
            #minimap {
                top: 5px;
                right: 5px;
                width: 80px;
                height: 80px;
            }
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <canvas id="minimap" width="160" height="160"></canvas>
    <div id="ui" style="display:none;"><span id="health">Health: 100</span> | <span id="ammo">Ammo: 50</span> | <span id="kills">Kills: 0</span> | <span id="weapon">Weapon: Gun</span></div>
    <div id="instructions">WASD: Move | Mouse: Look | Click: Attack | Right-Click: Plasma Ball (10 ammo) | 1: Baton | 2: Rifle | E: Door</div>
    <div id="crosshair" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#0ff;font-size:24px;pointer-events:none;text-shadow:0 0 10px #0ff;">+</div>
    <!-- Touch controls for mobile -->
    <div id="touch-controls">
        <div id="look-zone"></div>
        <div id="joystick-zone">
            <div id="joystick-knob"></div>
        </div>
        <div id="btn-attack" class="touch-btn">FIRE</div>
        <div id="btn-door" class="touch-btn">DOOR</div>
        <div id="btn-weapon1" class="touch-btn">1</div>
        <div id="btn-weapon2" class="touch-btn">2</div>
    </div>
    <script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const minimap = document.getElementById('minimap');
const minimapCtx = minimap.getContext('2d');

// Dynamic screen dimensions
let SCREEN_W = 800;
let SCREEN_H = 600;
const FOV = Math.PI / 3;
const HALF_FOV = FOV / 2;
let NUM_RAYS = 320;
const MAX_DEPTH = 20;
let SCALE = SCREEN_W / NUM_RAYS;
let depthBuffer = new Array(NUM_RAYS);

// Check if touch device
const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

// Resize canvas to fit screen with 4:3 aspect ratio
function resizeCanvas() {
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    // Reserve bottom quarter for controls on touch devices
    const controlsHeight = isTouchDevice ? Math.floor(windowHeight * 0.25) : 0;
    const availableHeight = windowHeight - controlsHeight;

    // Calculate largest 4:3 rectangle that fits in available space
    const targetRatio = 4 / 3;
    const availableRatio = windowWidth / availableHeight;

    let width, height;
    if (availableRatio > targetRatio) {
        // Available area is wider than 4:3, constrain by height
        height = availableHeight;
        width = height * targetRatio;
    } else {
        // Available area is taller than 4:3, constrain by width
        width = windowWidth;
        height = width / targetRatio;
    }

    canvas.width = width;
    canvas.height = height;

    // Set CSS size to match (prevents stretching)
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';

    // Center the canvas horizontally, position at top of available area
    canvas.style.position = 'absolute';
    canvas.style.left = ((windowWidth - width) / 2) + 'px';
    canvas.style.top = ((availableHeight - height) / 2) + 'px';

    SCREEN_W = width;
    SCREEN_H = height;

    // Adjust ray count based on width for performance
    NUM_RAYS = Math.min(640, Math.max(200, Math.floor(width / 2)));
    SCALE = SCREEN_W / NUM_RAYS;

    // Resize depth buffer
    depthBuffer = new Array(NUM_RAYS);

    // Position touch controls in bottom quarter
    if (isTouchDevice) {
        const touchControls = document.getElementById('touch-controls');
        touchControls.style.top = (windowHeight - controlsHeight) + 'px';
        touchControls.style.height = controlsHeight + 'px';
        touchControls.style.bottom = 'auto';
    }
}

// Initial resize
resizeCanvas();

// Resize on window change
window.addEventListener('resize', resizeCanvas);

// Map: 1 = wall, 0 = empty, 2 = door, 3 = elevator door, 4 = elevator interior
const MAP_W = 16;
const MAP_H = 16;
const MAP = [];
const ELEVATOR = { x: 0, y: 0 };
const doors = [];
let playerStart = { x: 1.5, y: 1.5 };
let enemies = [];

// Generate random map with contiguous hallway
function generateMap() {
    // Fill with walls
    for (let y = 0; y < MAP_H; y++) {
        MAP[y] = [];
        for (let x = 0; x < MAP_W; x++) {
            MAP[y][x] = 1;
        }
    }

    // Track hallway tiles for later use
    const hallwayTiles = [];

    // Start position (near top-left corner)
    let cx = 2;
    let cy = 2;
    MAP[cy][cx] = 0;
    hallwayTiles.push({ x: cx, y: cy });

    // Random walk to create winding hallway
    const directions = [
        { dx: 1, dy: 0 },  // right
        { dx: -1, dy: 0 }, // left
        { dx: 0, dy: 1 },  // down
        { dx: 0, dy: -1 }  // up
    ];

    let currentDir = 0; // Start going right
    const minHallwayLength = 40 + Math.floor(Math.random() * 20);

    while (hallwayTiles.length < minHallwayLength) {
        // Occasionally change direction (prefer continuing straight)
        if (Math.random() < 0.3) {
            // Turn left or right relative to current direction
            if (Math.random() < 0.5) {
                currentDir = (currentDir + 1) % 4;
            } else {
                currentDir = (currentDir + 3) % 4;
            }
        }

        const dir = directions[currentDir];
        const nx = cx + dir.dx;
        const ny = cy + dir.dy;

        // Check bounds (stay away from edges)
        if (nx >= 2 && nx < MAP_W - 2 && ny >= 2 && ny < MAP_H - 2) {
            // Carve the hallway
            if (MAP[ny][nx] === 1) {
                MAP[ny][nx] = 0;
                hallwayTiles.push({ x: nx, y: ny });
            }
            cx = nx;
            cy = ny;
        } else {
            // Hit boundary, change direction
            currentDir = (currentDir + 1) % 4;
        }
    }

    // Find the tile furthest from start for elevator
    let maxDist = 0;
    let elevatorTile = hallwayTiles[hallwayTiles.length - 1];
    for (const tile of hallwayTiles) {
        const dist = Math.abs(tile.x - 2) + Math.abs(tile.y - 2);
        if (dist > maxDist) {
            maxDist = dist;
            elevatorTile = tile;
        }
    }

    // Place elevator interior (no door - just walk in to win)
    ELEVATOR.x = elevatorTile.x;
    ELEVATOR.y = elevatorTile.y;
    MAP[elevatorTile.y][elevatorTile.x] = 4; // Elevator interior

    // Add some doors along the hallway (at random positions)
    const numDoors = 3 + Math.floor(Math.random() * 4);
    const doorCandidates = hallwayTiles.filter(tile => {
        // Don't place doors near start, elevator, or map edges
        const distFromStart = Math.abs(tile.x - 2) + Math.abs(tile.y - 2);
        const distFromElevator = Math.abs(tile.x - elevatorTile.x) + Math.abs(tile.y - elevatorTile.y);
        return distFromStart > 3 && distFromElevator > 2 && MAP[tile.y][tile.x] === 0;
    });

    for (let i = 0; i < numDoors && doorCandidates.length > 0; i++) {
        const idx = Math.floor(Math.random() * doorCandidates.length);
        const tile = doorCandidates.splice(idx, 1)[0];
        MAP[tile.y][tile.x] = 2;
        doors.push({ x: tile.x, y: tile.y, state: 0, opening: false, type: 'normal' });
    }

    // Set player start (first hallway tile)
    playerStart = { x: hallwayTiles[0].x + 0.5, y: hallwayTiles[0].y + 0.5 };

    // Generate enemies at random positions along hallway
    const numEnemies = 5 + Math.floor(Math.random() * 6); // 5-10 enemies
    const enemyCandidates = hallwayTiles.filter(tile => {
        const distFromStart = Math.abs(tile.x - hallwayTiles[0].x) + Math.abs(tile.y - hallwayTiles[0].y);
        return distFromStart > 4 && MAP[tile.y][tile.x] === 0;
    });

    enemies = [];
    for (let i = 0; i < numEnemies && enemyCandidates.length > 0; i++) {
        const idx = Math.floor(Math.random() * enemyCandidates.length);
        const tile = enemyCandidates.splice(idx, 1)[0];
        enemies.push({
            x: tile.x + 0.5,
            y: tile.y + 0.5,
            health: 30 * currentLevel, // Enemies get stronger each level
            speed: 0.02,
            alive: true,
            dying: false,
            deathTimer: 0,
            seen: false,
            damageFlash: 0
        });
    }
}

// Game state: 'playing', 'gameover', 'victory'
let gameState = 'playing';
let currentLevel = 1;

// Frame rate limiting
const TARGET_FPS = 120;
const FRAME_TIME = 1000 / TARGET_FPS;
let lastFrameTime = 0;

generateMap();

// Player - start position set by map generator
let player = { x: playerStart.x, y: playerStart.y, angle: 0, speed: 0.06, rotSpeed: 0.04, health: 100, ammo: 50, kills: 0 };

// Restart the game with a fresh map (full reset)
function restartGame() {
    currentLevel = 1;
    player.health = 100;
    player.ammo = 50;
    player.kills = 0;
    nextLevel(true);
}

// Advance to next level (keeps health/ammo if not a full reset)
function nextLevel(fullReset = false) {
    // Clear arrays
    MAP.length = 0;
    doors.length = 0;
    enemies.length = 0;
    lights.length = 0;
    ammoBoxes.length = 0;
    healthPacks.length = 0;
    plasmaBalls.length = 0;

    // Reset victory state (music keeps playing independently)
    victoryPlayed = false;

    // Regenerate map, enemies, lights, ammo, health
    generateMap();
    generateLights();
    generateAmmoBoxes();
    generateHealthPacks();

    // Reset player position (keep health/ammo unless full reset)
    player.x = playerStart.x;
    player.y = playerStart.y;
    player.angle = 0;
    rawMouseAngle = 0;

    // Reset other state
    shootCooldown = 0;
    muzzleFlash = 0;
    damageFlash = 0;
    plasmaballCooldown = 0;
    headLookDir = 0;
    headLookTimer = 0;
    lastPlayerAngle = 0;
    headDamageFlash = 0;
    currentWeapon = 1;
    swingAnimation = 0;

    // Clear key states to prevent immediate actions
    for (const key in keys) {
        keys[key] = false;
    }

    // Reset game state
    gameState = 'playing';
}

// Light sprites - randomly generated along hallways
const lights = [];
function generateLights() {
    const numLights = 5 + Math.floor(Math.random() * 6); // 5-10 lights
    // Find walkable floor positions (tile 0)
    const walkable = [];
    for (let y = 0; y < MAP_H; y++) {
        for (let x = 0; x < MAP_W; x++) {
            if (MAP[y][x] === 0) {
                walkable.push({ x: x + 0.5, y: y + 0.5 });
            }
        }
    }
    // Randomly pick positions for lights
    for (let i = 0; i < numLights && walkable.length > 0; i++) {
        const idx = Math.floor(Math.random() * walkable.length);
        const pos = walkable.splice(idx, 1)[0];
        // Offset slightly toward a wall for wall-mounted effect
        const offsetX = (Math.random() - 0.5) * 0.6;
        const offsetY = (Math.random() - 0.5) * 0.6;
        lights.push({
            x: pos.x + offsetX,
            y: pos.y + offsetY,
            color: '#0cf',
            phase: Math.random() * Math.PI * 2 // For flicker variation
        });
    }
}
generateLights();

// Ammo boxes - randomly generated along hallways
const ammoBoxes = [];
function generateAmmoBoxes() {
    const numBoxes = 3 + Math.floor(Math.random() * 4); // 3-6 ammo boxes
    const walkable = [];
    for (let y = 0; y < MAP_H; y++) {
        for (let x = 0; x < MAP_W; x++) {
            if (MAP[y][x] === 0) {
                walkable.push({ x: x + 0.5, y: y + 0.5 });
            }
        }
    }
    for (let i = 0; i < numBoxes && walkable.length > 0; i++) {
        const idx = Math.floor(Math.random() * walkable.length);
        const pos = walkable.splice(idx, 1)[0];
        ammoBoxes.push({
            x: pos.x,
            y: pos.y,
            collected: false
        });
    }
}
generateAmmoBoxes();

// Health packs - randomly generated along hallways
const healthPacks = [];
function generateHealthPacks() {
    const numPacks = 2 + Math.floor(Math.random() * 3); // 2-4 health packs
    const walkable = [];
    for (let y = 0; y < MAP_H; y++) {
        for (let x = 0; x < MAP_W; x++) {
            if (MAP[y][x] === 0) {
                walkable.push({ x: x + 0.5, y: y + 0.5 });
            }
        }
    }
    for (let i = 0; i < numPacks && walkable.length > 0; i++) {
        const idx = Math.floor(Math.random() * walkable.length);
        const pos = walkable.splice(idx, 1)[0];
        healthPacks.push({
            x: pos.x,
            y: pos.y,
            collected: false
        });
    }
}
generateHealthPacks();

// Shooting state
let shootCooldown = 0;
let muzzleFlash = 0;
let damageFlash = 0;

// Plasma ball projectiles
const plasmaBalls = [];
let plasmaballCooldown = 0;

// HUD space-man head state
let headLookDir = 0; // -1 left, 0 center, 1 right
let headLookTimer = 0;
let lastPlayerAngle = 0;
let headDamageFlash = 0;

// Weapon system: 0 = hammer (melee), 1 = gun (ranged)
let currentWeapon = 1;
let swingAnimation = 0; // For hammer swing

// === MUSIC SYSTEM ===
let audioCtx = null;
let musicStarted = false;
let musicPlaying = false;
let victoryPlayed = false;

function startMusic() {
    if (musicStarted) return;
    musicStarted = true;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    const BPM = 140;
    const beatTime = 60 / BPM;
    const barTime = beatTime * 4;

    // Master volume
    const masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.4;
    masterGain.connect(audioCtx.destination);

    // Kick drum
    function playKick(time) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = 'sine';
        osc.frequency.setValueAtTime(150, time);
        osc.frequency.exponentialRampToValueAtTime(30, time + 0.1);

        gain.gain.setValueAtTime(1, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(time);
        osc.stop(time + 0.3);
    }

    // Hi-hat
    function playHiHat(time, accent = false) {
        const bufferSize = audioCtx.sampleRate * 0.05;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;

        const filter = audioCtx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 8000;

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(accent ? 0.15 : 0.08, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);

        noise.start(time);
        noise.stop(time + 0.05);
    }

    // Bass synth
    function playBass(time, freq, duration = 0.2) {
        const osc = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        osc2.type = 'square';
        osc2.frequency.value = freq * 0.5;

        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(800, time);
        filter.frequency.exponentialRampToValueAtTime(200, time + duration);

        gain.gain.setValueAtTime(0.3, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + duration);

        osc.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);

        osc.start(time);
        osc2.start(time);
        osc.stop(time + duration);
        osc2.stop(time + duration);
    }

    // Synth pad (atmospheric)
    function playPad(time, freq, duration = 2) {
        const osc = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        osc2.type = 'sawtooth';
        osc2.frequency.value = freq * 1.005; // Slight detune for richness

        filter.type = 'lowpass';
        filter.frequency.value = 1500;
        filter.Q.value = 2;

        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.08, time + 0.3);
        gain.gain.linearRampToValueAtTime(0.08, time + duration - 0.3);
        gain.gain.linearRampToValueAtTime(0, time + duration);

        osc.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);

        osc.start(time);
        osc2.start(time);
        osc.stop(time + duration);
        osc2.stop(time + duration);
    }

    // Arpeggio synth
    function playArp(time, freq) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc.type = 'square';
        osc.frequency.value = freq;

        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(3000, time);
        filter.frequency.exponentialRampToValueAtTime(500, time + 0.15);

        gain.gain.setValueAtTime(0.1, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);

        osc.start(time);
        osc.stop(time + 0.15);
    }

    // Schedule music loop
    function scheduleBar(barStartTime, barNum) {
        // Kick on 1, 2, 3, 4 (four-on-floor)
        for (let beat = 0; beat < 4; beat++) {
            playKick(barStartTime + beat * beatTime);
        }

        // Hi-hats on eighth notes
        for (let i = 0; i < 8; i++) {
            playHiHat(barStartTime + i * beatTime * 0.5, i % 2 === 0);
        }

        // Bass line (minor key pattern)
        const bassNotes = [55, 55, 65.41, 73.42]; // A1, A1, C2, D2
        const bassPattern = barNum % 2 === 0 ? [0, 0, 1, 2] : [0, 3, 1, 0];
        for (let i = 0; i < 4; i++) {
            playBass(barStartTime + i * beatTime, bassNotes[bassPattern[i]], beatTime * 0.8);
        }

        // Pad chord every 2 bars
        if (barNum % 2 === 0) {
            const padFreqs = barNum % 4 === 0 ? [220, 261.63, 329.63] : [196, 246.94, 293.66]; // Am, G
            padFreqs.forEach(f => playPad(barStartTime, f, barTime * 2));
        }

        // Arpeggio pattern
        const arpNotes = [440, 523.25, 659.25, 523.25, 440, 392, 440, 523.25]; // A4, C5, E5...
        for (let i = 0; i < 8; i++) {
            if ((barNum + i) % 3 !== 0) { // Add some variation
                playArp(barStartTime + i * beatTime * 0.5, arpNotes[i]);
            }
        }
    }

    // Main music scheduler
    let nextBarTime = audioCtx.currentTime + 0.1;
    let barNumber = 0;

    function scheduler() {
        if (!musicPlaying) return; // Stop scheduling when music stops
        while (nextBarTime < audioCtx.currentTime + 0.5) {
            scheduleBar(nextBarTime, barNumber);
            nextBarTime += barTime;
            barNumber++;
        }
        setTimeout(scheduler, 100);
    }

    musicPlaying = true;
    scheduler();
}

function stopMusic() {
    musicPlaying = false;
}

// === SOUND EFFECTS ===
function ensureAudioCtx() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    return audioCtx;
}

function playGunSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Plasma zap sound
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(800, now);
    osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);

    gain.gain.setValueAtTime(0.15, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.1);

    // Add a click/snap
    const osc2 = ctx.createOscillator();
    const gain2 = ctx.createGain();
    osc2.type = 'square';
    osc2.frequency.value = 150;
    gain2.gain.setValueAtTime(0.1, now);
    gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
    osc2.connect(gain2);
    gain2.connect(ctx.destination);
    osc2.start(now);
    osc2.stop(now + 0.03);
}

function playHammerSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Whoosh sound (noise burst)
    const bufferSize = ctx.sampleRate * 0.15;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
    }

    const noise = ctx.createBufferSource();
    noise.buffer = buffer;

    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 400;
    filter.Q.value = 1;

    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.12, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

    noise.connect(filter);
    filter.connect(gain);
    gain.connect(ctx.destination);

    noise.start(now);
    noise.stop(now + 0.15);

    // Electric zap
    const osc = ctx.createOscillator();
    const oscGain = ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(200, now + 0.05);
    osc.frequency.exponentialRampToValueAtTime(80, now + 0.12);
    oscGain.gain.setValueAtTime(0.08, now + 0.05);
    oscGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
    osc.connect(oscGain);
    oscGain.connect(ctx.destination);
    osc.start(now + 0.05);
    osc.stop(now + 0.12);
}

function playEnemyHitSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Soft thud
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(100, now);
    osc.frequency.exponentialRampToValueAtTime(50, now + 0.08);

    gain.gain.setValueAtTime(0.12, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.08);
}

function playEnemyRoarSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Scary descending growl
    const osc = ctx.createOscillator();
    const osc2 = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(180, now);
    osc.frequency.exponentialRampToValueAtTime(60, now + 0.4);

    osc2.type = 'square';
    osc2.frequency.setValueAtTime(185, now);
    osc2.frequency.exponentialRampToValueAtTime(55, now + 0.4);

    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(600, now);
    filter.frequency.exponentialRampToValueAtTime(200, now + 0.4);

    gain.gain.setValueAtTime(0.15, now);
    gain.gain.linearRampToValueAtTime(0.2, now + 0.1);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

    osc.connect(filter);
    osc2.connect(filter);
    filter.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc2.start(now);
    osc.stop(now + 0.4);
    osc2.stop(now + 0.4);

    // Add a harsh noise burst
    const bufferSize = ctx.sampleRate * 0.15;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
    }

    const noise = ctx.createBufferSource();
    noise.buffer = buffer;

    const noiseFilter = ctx.createBiquadFilter();
    noiseFilter.type = 'bandpass';
    noiseFilter.frequency.value = 300;
    noiseFilter.Q.value = 2;

    const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(0.08, now);
    noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

    noise.connect(noiseFilter);
    noiseFilter.connect(noiseGain);
    noiseGain.connect(ctx.destination);

    noise.start(now);
    noise.stop(now + 0.15);
}

function playDoorOpenSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Hydraulic hiss
    const bufferSize = ctx.sampleRate * 0.4;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        const env = Math.exp(-i / (bufferSize * 0.3));
        data[i] = (Math.random() * 2 - 1) * env;
    }

    const noise = ctx.createBufferSource();
    noise.buffer = buffer;

    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.setValueAtTime(2000, now);
    filter.frequency.exponentialRampToValueAtTime(500, now + 0.3);
    filter.Q.value = 2;

    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.12, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

    noise.connect(filter);
    filter.connect(gain);
    gain.connect(ctx.destination);

    noise.start(now);
    noise.stop(now + 0.4);

    // Mechanical clunk
    const osc = ctx.createOscillator();
    const oscGain = ctx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(80, now);
    osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
    oscGain.gain.setValueAtTime(0.1, now);
    oscGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
    osc.connect(oscGain);
    oscGain.connect(ctx.destination);
    osc.start(now);
    osc.stop(now + 0.1);
}

function playAmmoPickupSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Quick ascending blip
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(400, now);
    osc.frequency.exponentialRampToValueAtTime(800, now + 0.08);

    gain.gain.setValueAtTime(0.1, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.1);

    // Second higher blip
    const osc2 = ctx.createOscillator();
    const gain2 = ctx.createGain();

    osc2.type = 'square';
    osc2.frequency.setValueAtTime(600, now + 0.05);
    osc2.frequency.exponentialRampToValueAtTime(1200, now + 0.12);

    gain2.gain.setValueAtTime(0.08, now + 0.05);
    gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

    osc2.connect(gain2);
    gain2.connect(ctx.destination);

    osc2.start(now + 0.05);
    osc2.stop(now + 0.15);
}

function playPlayerHitSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // 8-bit "oof" sound - short low grunt
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(150, now);
    osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);

    gain.gain.setValueAtTime(0.15, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.12);

    // Add some noise for texture
    const bufferSize = ctx.sampleRate * 0.08;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize) * 0.5;
    }

    const noise = ctx.createBufferSource();
    noise.buffer = buffer;

    const noiseFilter = ctx.createBiquadFilter();
    noiseFilter.type = 'lowpass';
    noiseFilter.frequency.value = 400;

    const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(0.08, now);
    noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

    noise.connect(noiseFilter);
    noiseFilter.connect(noiseGain);
    noiseGain.connect(ctx.destination);

    noise.start(now);
    noise.stop(now + 0.08);
}

function playEmptyClickSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Short dry click
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(120, now);
    osc.frequency.exponentialRampToValueAtTime(60, now + 0.05);

    gain.gain.setValueAtTime(0.25, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.05);
}

function playPlasmaBallSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Mid thump
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(150, now);
    osc.frequency.exponentialRampToValueAtTime(80, now + 0.2);

    gain.gain.setValueAtTime(0.2, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.25);

    // Mid rumble
    const osc2 = ctx.createOscillator();
    const gain2 = ctx.createGain();

    osc2.type = 'sawtooth';
    osc2.frequency.setValueAtTime(120, now);
    osc2.frequency.exponentialRampToValueAtTime(60, now + 0.25);

    gain2.gain.setValueAtTime(0.1, now);
    gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.25);

    osc2.connect(gain2);
    gain2.connect(ctx.destination);

    osc2.start(now);
    osc2.stop(now + 0.25);
}

function playHealthPickupSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Warm healing tone
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(440, now);
    osc.frequency.exponentialRampToValueAtTime(880, now + 0.15);

    gain.gain.setValueAtTime(0.12, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.2);

    // Harmony note
    const osc2 = ctx.createOscillator();
    const gain2 = ctx.createGain();

    osc2.type = 'sine';
    osc2.frequency.setValueAtTime(554, now + 0.05);
    osc2.frequency.exponentialRampToValueAtTime(1108, now + 0.18);

    gain2.gain.setValueAtTime(0.08, now + 0.05);
    gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.22);

    osc2.connect(gain2);
    gain2.connect(ctx.destination);

    osc2.start(now + 0.05);
    osc2.stop(now + 0.22);
}

function playEnemyDeathSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Descending tone (alien death cry)
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(300, now);
    osc.frequency.exponentialRampToValueAtTime(60, now + 0.3);

    gain.gain.setValueAtTime(0.1, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.3);

    // Static burst
    const bufferSize = ctx.sampleRate * 0.2;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize) * 0.5;
    }

    const noise = ctx.createBufferSource();
    noise.buffer = buffer;

    const filter = ctx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 2000;

    const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(0.06, now);
    noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

    noise.connect(filter);
    filter.connect(noiseGain);
    noiseGain.connect(ctx.destination);

    noise.start(now);
    noise.stop(now + 0.2);
}

function playVictoryMusic() {
    if (victoryPlayed) return;
    victoryPlayed = true;
    // Don't stop the background music - just play victory chime on top

    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    const masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.4;
    masterGain.connect(audioCtx.destination);

    // Soft victory chime
    function playChime(time, freq, duration = 0.4) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = 'sine';
        osc.frequency.value = freq;

        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.12, time + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.01, time + duration);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(time);
        osc.stop(time + duration);
    }

    const now = audioCtx.currentTime;

    // Simple ascending chime (C-E-G)
    playChime(now, 523.25, 0.5);        // C5
    playChime(now + 0.15, 659.25, 0.5); // E5
    playChime(now + 0.3, 783.99, 0.8);  // G5 (held slightly longer)
}

// Input - use e.code for reliable key detection
const keys = {};
let rawMouseAngle = 0; // Accumulate raw mouse movement at full resolution
const MOUSE_SENSITIVITY = 0.01;

window.addEventListener('keydown', e => {
    keys[e.code] = true;
    e.preventDefault();
});
window.addEventListener('keyup', e => {
    keys[e.code] = false;
});

canvas.addEventListener('click', () => {
    // Handle end screens
    if (gameState === 'gameover') {
        restartGame();
        return;
    }
    if (gameState === 'victory') {
        currentLevel++;
        nextLevel();
        return;
    }
    startMusic(); // Start music on first click
    if (document.pointerLockElement !== canvas) {
        // Request pointer lock with unadjusted movement for raw mouse input (if supported)
        canvas.requestPointerLock({ unadjustedMovement: true }).catch(() => {
            // Fall back to standard pointer lock if unadjusted not supported
            canvas.requestPointerLock();
        });
    }
});
document.addEventListener('mousemove', e => {
    if (document.pointerLockElement === canvas) {
        // Accumulate raw mouse pixels at full resolution, then scale
        rawMouseAngle += e.movementX;
        player.angle = rawMouseAngle * MOUSE_SENSITIVITY;
    }
});
document.addEventListener('mousedown', e => {
    if (document.pointerLockElement === canvas) {
        if (e.button === 0) {
            attack();
        } else if (e.button === 2) {
            firePlasmaBall();
        }
    }
});

// Prevent context menu on right click
document.addEventListener('contextmenu', e => {
    e.preventDefault();
});

// === TOUCH CONTROLS ===
const touchState = {
    joystick: { active: false, id: null, startX: 0, startY: 0, dx: 0, dy: 0 },
    look: { active: false, id: null, lastX: 0 }
};

// Joystick for movement
const joystickZone = document.getElementById('joystick-zone');
const joystickKnob = document.getElementById('joystick-knob');

joystickZone.addEventListener('touchstart', e => {
    e.preventDefault();
    startMusic();
    const touch = e.changedTouches[0];
    const rect = joystickZone.getBoundingClientRect();
    touchState.joystick.active = true;
    touchState.joystick.id = touch.identifier;
    touchState.joystick.startX = rect.left + rect.width / 2;
    touchState.joystick.startY = rect.top + rect.height / 2;
    updateJoystick(touch.clientX, touch.clientY);
});

joystickZone.addEventListener('touchmove', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
        if (touch.identifier === touchState.joystick.id) {
            updateJoystick(touch.clientX, touch.clientY);
        }
    }
});

joystickZone.addEventListener('touchend', e => {
    for (const touch of e.changedTouches) {
        if (touch.identifier === touchState.joystick.id) {
            touchState.joystick.active = false;
            touchState.joystick.dx = 0;
            touchState.joystick.dy = 0;
            joystickKnob.style.transform = 'translate(-50%, -50%)';
        }
    }
});

joystickZone.addEventListener('touchcancel', e => {
    touchState.joystick.active = false;
    touchState.joystick.dx = 0;
    touchState.joystick.dy = 0;
    joystickKnob.style.transform = 'translate(-50%, -50%)';
});

function updateJoystick(x, y) {
    const maxDist = 50;
    let dx = x - touchState.joystick.startX;
    let dy = y - touchState.joystick.startY;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist > maxDist) {
        dx = (dx / dist) * maxDist;
        dy = (dy / dist) * maxDist;
    }

    touchState.joystick.dx = dx / maxDist;
    touchState.joystick.dy = dy / maxDist;

    joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
}

// Look zone for camera rotation
const lookZone = document.getElementById('look-zone');

lookZone.addEventListener('touchstart', e => {
    e.preventDefault();
    startMusic();
    const touch = e.changedTouches[0];
    touchState.look.active = true;
    touchState.look.id = touch.identifier;
    touchState.look.lastX = touch.clientX;
});

lookZone.addEventListener('touchmove', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
        if (touch.identifier === touchState.look.id) {
            const deltaX = touch.clientX - touchState.look.lastX;
            rawMouseAngle += deltaX * (0.008 / MOUSE_SENSITIVITY);
            player.angle = rawMouseAngle * MOUSE_SENSITIVITY;
            touchState.look.lastX = touch.clientX;
        }
    }
});

lookZone.addEventListener('touchend', e => {
    for (const touch of e.changedTouches) {
        if (touch.identifier === touchState.look.id) {
            touchState.look.active = false;
        }
    }
});

lookZone.addEventListener('touchcancel', e => {
    touchState.look.active = false;
});

// Attack button
const btnAttack = document.getElementById('btn-attack');
btnAttack.addEventListener('touchstart', e => {
    e.preventDefault();
    startMusic();
    if (gameState === 'gameover') {
        restartGame();
    } else if (gameState === 'victory') {
        currentLevel++;
        nextLevel();
    } else {
        attack();
    }
});

// Door button
const btnDoor = document.getElementById('btn-door');
btnDoor.addEventListener('touchstart', e => {
    e.preventDefault();
    startMusic();
    tryOpenDoor();
});

// Weapon buttons
const btnWeapon1 = document.getElementById('btn-weapon1');
const btnWeapon2 = document.getElementById('btn-weapon2');

btnWeapon1.addEventListener('touchstart', e => {
    e.preventDefault();
    currentWeapon = 0;
});

btnWeapon2.addEventListener('touchstart', e => {
    e.preventDefault();
    currentWeapon = 1;
});

// Weapon switching and restart
window.addEventListener('keydown', e => {
    if (e.code === 'Digit1') currentWeapon = 0; // Hammer
    if (e.code === 'Digit2') currentWeapon = 1; // Gun

    // Handle end screens
    if (e.code === 'Space' && gameState === 'gameover') {
        restartGame();
    }
    if (e.code === 'Space' && gameState === 'victory') {
        currentLevel++;
        nextLevel();
    }
});

// Get door at position
function getDoor(x, y) {
    return doors.find(d => d.x === x && d.y === y);
}

// Check if position is blocked (wall or closed door)
function isWall(x, y) {
    const mapX = Math.floor(x);
    const mapY = Math.floor(y);
    if (mapX < 0 || mapX >= MAP_W || mapY < 0 || mapY >= MAP_H) return true;
    const tile = MAP[mapY][mapX];
    if (tile === 1) return true;
    if (tile === 2 || tile === 3) { // Normal door or elevator door
        const door = getDoor(mapX, mapY);
        return door && door.state < 0.8; // Door blocks if less than 80% open
    }
    // Tile 4 (elevator interior) is walkable
    return false;
}

// Check if player is in the elevator
function isInElevator() {
    const px = Math.floor(player.x);
    const py = Math.floor(player.y);
    return px === ELEVATOR.x && py === ELEVATOR.y;
}

// Try to open nearby door
function tryOpenDoor() {
    const checkDist = 1.5;
    const px = player.x + Math.cos(player.angle) * checkDist;
    const py = player.y + Math.sin(player.angle) * checkDist;

    for (const door of doors) {
        const dx = (door.x + 0.5) - player.x;
        const dy = (door.y + 0.5) - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 2 && door.state < 0.5 && !door.opening) {
            door.opening = true;
            playDoorOpenSound();
        }
    }
}

// Update doors (animate opening)
function updateDoors() {
    for (const door of doors) {
        if (door.opening && door.state < 1) {
            door.state += 0.05; // Opening speed
            if (door.state >= 1) {
                door.state = 1;
                door.opening = false;
            }
        }
    }
}

// Cast a single ray and return distance + wall hit position
function castRay(angle) {
    const sin = Math.sin(angle);
    const cos = Math.cos(angle);

    // DDA algorithm
    let mapX = Math.floor(player.x);
    let mapY = Math.floor(player.y);

    const deltaDistX = Math.abs(1 / cos) || 1e10;
    const deltaDistY = Math.abs(1 / sin) || 1e10;

    let stepX, stepY, sideDistX, sideDistY;

    if (cos < 0) {
        stepX = -1;
        sideDistX = (player.x - mapX) * deltaDistX;
    } else {
        stepX = 1;
        sideDistX = (mapX + 1 - player.x) * deltaDistX;
    }
    if (sin < 0) {
        stepY = -1;
        sideDistY = (player.y - mapY) * deltaDistY;
    } else {
        stepY = 1;
        sideDistY = (mapY + 1 - player.y) * deltaDistY;
    }

    let side = 0;
    let dist = 0;

    for (let i = 0; i < MAX_DEPTH * MAP_W; i++) {
        if (sideDistX < sideDistY) {
            sideDistX += deltaDistX;
            mapX += stepX;
            side = 0;
        } else {
            sideDistY += deltaDistY;
            mapY += stepY;
            side = 1;
        }

        if (mapX < 0 || mapX >= MAP_W || mapY < 0 || mapY >= MAP_H) break;

        const tile = MAP[mapY][mapX];
        if (tile === 1) {
            if (side === 0) dist = sideDistX - deltaDistX;
            else dist = sideDistY - deltaDistY;
            // Calculate wall hit position (0-1 along the wall)
            let wallX;
            if (side === 0) wallX = player.y + dist * sin;
            else wallX = player.x + dist * cos;
            wallX -= Math.floor(wallX);
            return { dist: dist || MAX_DEPTH, side, tile: 1, wallX };
        }
        if (tile === 2) { // Normal door
            const door = getDoor(mapX, mapY);
            if (door && door.state < 0.95) {
                if (side === 0) dist = sideDistX - deltaDistX;
                else dist = sideDistY - deltaDistY;
                let wallX;
                if (side === 0) wallX = player.y + dist * sin;
                else wallX = player.x + dist * cos;
                wallX -= Math.floor(wallX);
                return { dist: dist || MAX_DEPTH, side, tile: 2, doorState: door.state, wallX };
            }
        }
        if (tile === 3) { // Elevator door (green)
            const door = getDoor(mapX, mapY);
            if (door && door.state < 0.95) {
                if (side === 0) dist = sideDistX - deltaDistX;
                else dist = sideDistY - deltaDistY;
                let wallX;
                if (side === 0) wallX = player.y + dist * sin;
                else wallX = player.x + dist * cos;
                wallX -= Math.floor(wallX);
                return { dist: dist || MAX_DEPTH, side, tile: 3, doorState: door.state, wallX };
            }
        }
        // Tile 4 (exit portal) is not a wall - rays pass through
    }

    return { dist: MAX_DEPTH, side, tile: 0, wallX: 0 };
}

// Render 3D view
function render3D() {
    // Ceiling - dark spaceship interior with blue lighting strips
    const ceilGrad = ctx.createLinearGradient(0, 0, 0, SCREEN_H / 2);
    ceilGrad.addColorStop(0, '#0a1520');
    ceilGrad.addColorStop(0.3, '#0d1a28');
    ceilGrad.addColorStop(0.7, '#101820');
    ceilGrad.addColorStop(1, '#1a2530');
    ctx.fillStyle = ceilGrad;
    ctx.fillRect(0, 0, SCREEN_W, SCREEN_H / 2);

    // Ceiling light strips
    ctx.fillStyle = '#304050';
    for (let x = 0; x < SCREEN_W; x += 80) {
        ctx.fillRect(x, SCREEN_H / 2 - 8, 40, 6);
    }
    ctx.fillStyle = '#5080a0';
    for (let x = 0; x < SCREEN_W; x += 80) {
        ctx.fillRect(x + 5, SCREEN_H / 2 - 6, 30, 2);
    }

    // Floor - metallic spaceship floor with grid pattern
    const floorGrad = ctx.createLinearGradient(0, SCREEN_H / 2, 0, SCREEN_H);
    floorGrad.addColorStop(0, '#252830');
    floorGrad.addColorStop(0.5, '#1a1d24');
    floorGrad.addColorStop(1, '#12151a');
    ctx.fillStyle = floorGrad;
    ctx.fillRect(0, SCREEN_H / 2, SCREEN_W, SCREEN_H / 2);


    // Cast rays
    for (let i = 0; i < NUM_RAYS; i++) {
        const rayAngle = player.angle - HALF_FOV + (i / NUM_RAYS) * FOV;
        const { dist, side, tile, doorState, wallX } = castRay(rayAngle);

        // Fix fisheye
        const correctedDist = dist * Math.cos(rayAngle - player.angle);

        // Wall height
        const wallHeight = Math.min(SCREEN_H * 1.5, SCREEN_H / correctedDist);
        const wallTop = (SCREEN_H - wallHeight) / 2;

        // Wall/door color with shading
        const shade = Math.max(0.2, 1 - correctedDist / MAX_DEPTH);
        let r, g, b;

        if (tile === 2) {
            // Metallic door
            const baseColor = side === 0 ? 160 : 140;
            const openAmount = doorState || 0;

            // Door dimensions
            const doorHeight = wallHeight * (1 - openAmount);
            const doorTop = wallTop + (wallHeight - doorHeight);

            // Check for border (edges of door)
            const isBorder = wallX < 0.08 || wallX > 0.92;

            // Check for handle area (right side, middle height)
            const isHandle = wallX > 0.75 && wallX < 0.85;

            if (isBorder) {
                // Darker metallic border
                r = Math.floor(50 * shade);
                g = Math.floor(55 * shade);
                b = Math.floor(60 * shade);
            } else {
                // Main door panel - metallic grey with subtle variation
                const innerX = (wallX - 0.08) / 0.84;
                const panelPos = (innerX * 2) % 1; // 2 panels
                const edgeDist = Math.min(panelPos, 1 - panelPos);
                const panelShade = 0.9 + edgeDist * 0.2;

                r = Math.floor(baseColor * shade * 0.55 * panelShade);
                g = Math.floor(baseColor * shade * 0.58 * panelShade);
                b = Math.floor(baseColor * shade * 0.65 * panelShade);
            }

            // Draw main door
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect(i * SCALE, doorTop, SCALE + 1, doorHeight);

            // Draw top border
            const borderSize = doorHeight * 0.06;
            ctx.fillStyle = `rgb(${Math.floor(50 * shade)},${Math.floor(55 * shade)},${Math.floor(60 * shade)})`;
            ctx.fillRect(i * SCALE, doorTop, SCALE + 1, borderSize);

            // Draw handle
            if (isHandle && doorHeight > 0) {
                const handleTop = doorTop + doorHeight * 0.4;
                const handleHeight = doorHeight * 0.2;
                // Handle base - slightly lighter metal
                ctx.fillStyle = `rgb(${Math.floor(100 * shade)},${Math.floor(105 * shade)},${Math.floor(115 * shade)})`;
                ctx.fillRect(i * SCALE, handleTop, SCALE + 1, handleHeight);
                // Handle highlight
                if (wallX > 0.78 && wallX < 0.82) {
                    ctx.fillStyle = `rgb(${Math.floor(140 * shade)},${Math.floor(145 * shade)},${Math.floor(155 * shade)})`;
                    ctx.fillRect(i * SCALE, handleTop + handleHeight * 0.2, SCALE + 1, handleHeight * 0.6);
                }
            }
        } else if (tile === 3) {
            // Elevator door (bright green - escape route)
            const baseColor = side === 0 ? 180 : 150;
            const openAmount = doorState || 0;

            // Door dimensions
            const doorHeight = wallHeight * (1 - openAmount);
            const doorTop = wallTop + (wallHeight - doorHeight);

            // Check for border
            const isBorder = wallX < 0.06 || wallX > 0.94;

            // Check for handle area
            const isHandle = wallX > 0.72 && wallX < 0.82;

            if (isBorder) {
                // Bright border for escape door
                r = Math.floor(100 * shade);
                g = Math.floor(200 * shade);
                b = Math.floor(120 * shade);
            } else {
                // Inner panel
                const innerX = (wallX - 0.06) / 0.88;
                const panelPos = (innerX * 2) % 1; // 2 panels
                const nearEdge = panelPos < 0.05 || panelPos > 0.95;
                const highlight = nearEdge ? 0.2 : 0;

                r = Math.floor(baseColor * shade * (0.2 + highlight));
                g = Math.floor(baseColor * shade * (1.0 + highlight * 0.2));
                b = Math.floor(baseColor * shade * (0.3 + highlight));
            }

            // Draw main door
            ctx.fillStyle = `rgb(${Math.min(255,r)},${Math.min(255,g)},${Math.min(255,b)})`;
            ctx.fillRect(i * SCALE, doorTop, SCALE + 1, doorHeight);

            // Draw top border
            const borderSize = doorHeight * 0.05;
            ctx.fillStyle = `rgb(${Math.floor(100 * shade)},${Math.floor(200 * shade)},${Math.floor(120 * shade)})`;
            ctx.fillRect(i * SCALE, doorTop, SCALE + 1, borderSize);

            // Draw handle
            if (isHandle && doorHeight > 0) {
                const handleTop = doorTop + doorHeight * 0.4;
                const handleHeight = doorHeight * 0.2;
                // Handle base (metallic)
                ctx.fillStyle = `rgb(${Math.floor(150 * shade)},${Math.floor(160 * shade)},${Math.floor(155 * shade)})`;
                ctx.fillRect(i * SCALE, handleTop, SCALE + 1, handleHeight);
                // Handle grip highlight
                if (wallX > 0.75 && wallX < 0.79) {
                    ctx.fillStyle = `rgb(${Math.floor(200 * shade)},${Math.floor(210 * shade)},${Math.floor(205 * shade)})`;
                    ctx.fillRect(i * SCALE, handleTop + handleHeight * 0.15, SCALE + 1, handleHeight * 0.7);
                }
            }
        } else {
            // Spaceship wall (metallic blue-gray panels)
            const baseColor = side === 0 ? 160 : 130;

            // Use wallX for perspective-correct panel pattern (soft gradient)
            const panelPos = (wallX * 2) % 1; // 2 panels per wall tile
            const edgeDist = Math.min(panelPos, 1 - panelPos); // Distance to nearest edge
            const edgeFade = Math.min(1, edgeDist * 8); // Soft falloff near edges

            // Subtle darkening near panel edges, highlight in center
            const panelShade = 0.85 + edgeFade * 0.15;

            r = Math.floor(baseColor * shade * 0.4 * panelShade);
            g = Math.floor(baseColor * shade * 0.5 * panelShade);
            b = Math.floor(baseColor * shade * 0.7 * panelShade);

            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect(i * SCALE, wallTop, SCALE + 1, wallHeight);
        }

        // Store depth for sprite occlusion
        depthBuffer[i] = correctedDist;
    }

    // Render light sprites
    renderLights();

    // Render victory portal
    renderVictoryPortal();

    // Render ammo boxes
    renderAmmoBoxes();

    // Render health packs
    renderHealthPacks();

    // Render enemies as sprites
    renderSprites();

    // Render plasma balls
    renderPlasmaBalls();

    // Muzzle flash effect
    if (muzzleFlash > 0) {
        ctx.fillStyle = `rgba(255, 200, 50, ${muzzleFlash * 0.3})`;
        ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);
        muzzleFlash -= 0.2;
    }

    // Damage flash effect (red radial gradient)
    if (damageFlash > 0) {
        const gradient = ctx.createRadialGradient(SCREEN_W / 2, SCREEN_H / 2, 0, SCREEN_W / 2, SCREEN_H / 2, SCREEN_W * 0.7);
        gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
        gradient.addColorStop(0.5, `rgba(255, 0, 0, ${damageFlash * 0.15})`);
        gradient.addColorStop(1, `rgba(200, 0, 0, ${damageFlash * 0.4})`);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);
        damageFlash -= 0.05;
    }

    // Render weapon
    if (currentWeapon === 0) {
        renderHammer();
    } else {
        renderGun();
    }

    // Render HUD
    renderHUD();
}

// Render player's stun baton (sci-fi melee weapon)
function renderHammer() {
    const centerX = SCREEN_W / 2;
    const baseY = SCREEN_H;

    // Scale factor based on screen height (reference: 600px)
    const s = SCREEN_H / 600;

    // Check if baton is cooling down
    const isCoolingDown = shootCooldown > 0 && currentWeapon === 0;

    // Idle bob animation (disabled while cooling down)
    const bobX = isCoolingDown ? 0 : Math.sin(Date.now() * 0.004) * 10 * s;
    const bobY = isCoolingDown ? 0 : Math.abs(Math.cos(Date.now() * 0.008)) * 6 * s;

    // Swing animation (rotates the baton)
    const swingAngle = swingAnimation > 0 ? (1 - swingAnimation / 20) * Math.PI * 0.6 - 0.3 : 0;
    const swingOffsetX = swingAnimation > 0 ? Math.sin(swingAngle) * 100 * s : 0;
    const swingOffsetY = swingAnimation > 0 ? -Math.abs(Math.cos(swingAngle)) * 50 * s : 0;

    const batonX = centerX + bobX + 50 * s + swingOffsetX;
    const batonY = baseY + bobY - 100 * s + swingOffsetY;

    ctx.save();
    ctx.translate(batonX, batonY);
    ctx.scale(s, s);
    ctx.rotate(-0.4 + swingAngle); // Slight tilt + swing

    // Handle (metallic grip)
    ctx.fillStyle = '#2a3040';
    ctx.fillRect(-10, 20, 20, 160);

    // Grip ridges
    ctx.fillStyle = '#1a2030';
    for (let i = 0; i < 6; i++) {
        ctx.fillRect(-12, 40 + i * 22, 24, 8);
    }

    // Main body (sleek metallic)
    ctx.fillStyle = '#4a5565';
    ctx.fillRect(-14, -80, 28, 110);

    // Side panels
    ctx.fillStyle = '#3a4555';
    ctx.fillRect(-16, -70, 6, 90);
    ctx.fillRect(10, -70, 6, 90);

    // Energy prongs (top)
    ctx.fillStyle = '#5a6575';
    ctx.fillRect(-20, -110, 12, 35);
    ctx.fillRect(8, -110, 12, 35);

    // Glowing energy core (dimmed and static while cooling down)
    const glowPulse = isCoolingDown ? 0.3 : 0.6 + 0.4 * Math.sin(Date.now() * 0.015);
    ctx.fillStyle = `rgba(0, 200, 255, ${glowPulse})`;
    ctx.fillRect(-8, -100, 16, 50);

    // Energy between prongs
    ctx.fillStyle = `rgba(0, 255, 255, ${glowPulse * 0.8})`;
    ctx.fillRect(-16, -115, 32, 8);

    // Status light (orange while cooling down, green when ready)
    ctx.fillStyle = isCoolingDown ? '#f80' : '#0f8';
    ctx.fillRect(-4, 10, 8, 8);

    // Electric arc effect when swinging
    if (swingAnimation > 15) {
        ctx.strokeStyle = `rgba(0, 255, 255, ${(swingAnimation - 15) / 5})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-18, -115);
        ctx.lineTo(-25, -140);
        ctx.lineTo(-10, -130);
        ctx.lineTo(-30, -160);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(18, -115);
        ctx.lineTo(25, -140);
        ctx.lineTo(10, -130);
        ctx.lineTo(30, -160);
        ctx.stroke();

        // Glow effect
        ctx.fillStyle = `rgba(0, 255, 255, ${(swingAnimation - 15) / 8})`;
        ctx.beginPath();
        ctx.arc(0, -120, 40, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.restore();

    // Decrease swing animation
    if (swingAnimation > 0) swingAnimation--;
}

// Render player's gun (sci-fi plasma rifle)
function renderGun() {
    const centerX = SCREEN_W / 2;
    const baseY = SCREEN_H + 80; // Lower position so gun doesn't cover as much view

    // Scale factor based on screen height (reference: 600px)
    const s = SCREEN_H / 600;

    // Gun recoil animation
    const recoil = muzzleFlash > 0 ? muzzleFlash * 20 * s : 0;
    const bobX = Math.sin(Date.now() * 0.004) * 12 * s;
    const bobY = Math.abs(Math.cos(Date.now() * 0.008)) * 8 * s;

    const gunX = centerX + bobX;
    const gunY = baseY + bobY - recoil;

    ctx.save();
    ctx.translate(gunX, gunY);
    ctx.scale(s, s);

    // Gun hand/grip (gloved hand)
    ctx.fillStyle = '#2a3040';
    ctx.fillRect(-35, -70, 70, 80);
    ctx.fillStyle = '#1a2030';
    ctx.fillRect(-30, -60, 60, 60);

    // Gun body (main frame - sleek sci-fi)
    ctx.fillStyle = '#3a4555';
    ctx.fillRect(-40, -150, 80, 90);

    // Side panels
    ctx.fillStyle = '#2a3545';
    ctx.fillRect(-42, -145, 10, 75);
    ctx.fillRect(32, -145, 10, 75);

    // Gun barrel (elongated sci-fi)
    ctx.fillStyle = '#4a5565';
    ctx.fillRect(-15, -220, 30, 80);

    // Barrel core (glowing)
    const glowIntensity = 0.5 + 0.3 * Math.sin(Date.now() * 0.01);
    ctx.fillStyle = `rgba(0, 200, 255, ${glowIntensity})`;
    ctx.fillRect(-8, -215, 16, 70);

    // Barrel tip
    ctx.fillStyle = '#5a6575';
    ctx.fillRect(-18, -225, 36, 12);

    // Energy coils on barrel
    ctx.fillStyle = '#0af';
    for (let i = 0; i < 3; i++) {
        ctx.fillRect(-12, -200 + i * 25, 24, 3);
    }

    // Top rail
    ctx.fillStyle = '#4a5060';
    ctx.fillRect(-10, -165, 20, 8);

    // Side lights
    ctx.fillStyle = muzzleFlash > 0 ? '#f80' : '#0a8';
    ctx.fillRect(-38, -130, 6, 20);
    ctx.fillRect(32, -130, 6, 20);

    // Muzzle flash (plasma burst)
    if (muzzleFlash > 0.5) {
        ctx.fillStyle = '#0ff';
        ctx.beginPath();
        ctx.moveTo(0, -230);
        ctx.lineTo(-25, -270);
        ctx.lineTo(-6, -240);
        ctx.lineTo(0, -300);
        ctx.lineTo(6, -240);
        ctx.lineTo(25, -270);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(0, -230, 15, 0, Math.PI * 2);
        ctx.fill();

        // Plasma glow
        ctx.fillStyle = `rgba(0, 255, 255, ${muzzleFlash * 0.3})`;
        ctx.beginPath();
        ctx.arc(0, -230, 40, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.restore();
}

// Render HUD at bottom of screen (Doom-style)
function renderHUD() {
    // Scale factor based on screen height (reference: 600px)
    const s = Math.min(1, SCREEN_H / 600);
    const hudHeight = Math.floor(60 * s);
    const hudY = SCREEN_H - hudHeight;

    // HUD background (dark metallic panel)
    const hudGrad = ctx.createLinearGradient(0, hudY, 0, SCREEN_H);
    hudGrad.addColorStop(0, '#2a3040');
    hudGrad.addColorStop(0.1, '#1a2030');
    hudGrad.addColorStop(1, '#0a1020');
    ctx.fillStyle = hudGrad;
    ctx.fillRect(0, hudY, SCREEN_W, hudHeight);

    // Top border line
    ctx.fillStyle = '#4a6080';
    ctx.fillRect(0, hudY, SCREEN_W, 2);

    // Panel dividers (scaled positions)
    ctx.fillStyle = '#3a4050';
    ctx.fillRect(SCREEN_W * 0.25, hudY + 5 * s, 2, hudHeight - 10 * s);
    ctx.fillRect(SCREEN_W * 0.75, hudY + 5 * s, 2, hudHeight - 10 * s);

    // Update head look direction based on player turning
    const angleDiff = player.angle - lastPlayerAngle;
    if (Math.abs(angleDiff) > 0.02) {
        headLookDir = angleDiff > 0 ? 1 : -1;
        headLookTimer = 30;
    }
    lastPlayerAngle = player.angle;

    if (headLookTimer > 0) {
        headLookTimer--;
    } else {
        headLookDir = 0;
    }

    // Draw space-man head (center of HUD)
    const headX = SCREEN_W / 2;
    const headY = hudY + hudHeight / 2 + 2 * s;
    const headSize = 22 * s;

    ctx.save();
    ctx.translate(headX, headY);

    // Helmet (outer)
    ctx.fillStyle = '#4a5565';
    ctx.beginPath();
    ctx.arc(0, 0, headSize, 0, Math.PI * 2);
    ctx.fill();

    // Helmet rim
    ctx.fillStyle = '#3a4555';
    ctx.beginPath();
    ctx.arc(0, 0, headSize - 3 * s, 0, Math.PI * 2);
    ctx.fill();

    // Visor (dark)
    ctx.fillStyle = '#1a2535';
    ctx.beginPath();
    ctx.ellipse(0, 2 * s, headSize - 6 * s, headSize - 8 * s, 0, 0, Math.PI * 2);
    ctx.fill();

    // Visor reflection
    ctx.fillStyle = 'rgba(100, 180, 220, 0.3)';
    ctx.beginPath();
    ctx.ellipse(-5 * s, -2 * s, 6 * s, 4 * s, -0.3, 0, Math.PI * 2);
    ctx.fill();

    // Face inside visor
    const faceOffsetX = headLookDir * 4 * s;
    ctx.fillStyle = headDamageFlash > 0 ? '#ff8866' : '#e8c8a8';
    ctx.beginPath();
    ctx.ellipse(faceOffsetX, 3 * s, 10 * s, 12 * s, 0, 0, Math.PI * 2);
    ctx.fill();

    // Eyes
    const eyeOffsetX = headLookDir * 2 * s;
    ctx.fillStyle = '#222';
    ctx.fillRect(faceOffsetX - 5 * s + eyeOffsetX, -1 * s, 3 * s, 4 * s);
    ctx.fillRect(faceOffsetX + 2 * s + eyeOffsetX, -1 * s, 3 * s, 4 * s);

    // Eye whites/direction
    ctx.fillStyle = '#fff';
    ctx.fillRect(faceOffsetX - 5 * s + eyeOffsetX + (headLookDir > 0 ? 1 * s : 0), 0, 2 * s, 2 * s);
    ctx.fillRect(faceOffsetX + 2 * s + eyeOffsetX + (headLookDir > 0 ? 1 * s : 0), 0, 2 * s, 2 * s);

    // Mouth (changes with health)
    ctx.fillStyle = '#833';
    if (player.health > 60) {
        // Slight smile
        ctx.beginPath();
        ctx.arc(faceOffsetX, 10 * s, 4 * s, 0.1 * Math.PI, 0.9 * Math.PI);
        ctx.stroke();
    } else if (player.health > 30) {
        // Neutral
        ctx.fillRect(faceOffsetX - 3 * s, 9 * s, 6 * s, 2 * s);
    } else {
        // Grimace
        ctx.beginPath();
        ctx.arc(faceOffsetX, 12 * s, 4 * s, 1.1 * Math.PI, 1.9 * Math.PI);
        ctx.stroke();
    }

    // Helmet lights
    ctx.fillStyle = player.health > 30 ? '#0f8' : '#f44';
    ctx.fillRect(-headSize + 4 * s, -8 * s, 4 * s, 4 * s);
    ctx.fillRect(headSize - 8 * s, -8 * s, 4 * s, 4 * s);

    ctx.restore();

    // Decrease damage flash
    if (headDamageFlash > 0) headDamageFlash--;

    // Left panel - Health
    ctx.fillStyle = '#0cf';
    ctx.font = `bold ${Math.floor(14 * s)}px monospace`;
    ctx.textAlign = 'left';
    ctx.fillText('HEALTH', 15 * s, hudY + 20 * s);

    const healthColor = player.health > 60 ? '#0f8' : player.health > 30 ? '#fa0' : '#f44';
    ctx.fillStyle = healthColor;
    ctx.font = `bold ${Math.floor(28 * s)}px monospace`;
    ctx.fillText(Math.floor(player.health), 15 * s, hudY + 48 * s);

    // Health bar
    ctx.fillStyle = '#1a2030';
    ctx.fillRect(90 * s, hudY + 30 * s, 100 * s, 16 * s);
    ctx.fillStyle = healthColor;
    ctx.fillRect(92 * s, hudY + 32 * s, Math.max(0, (player.health / 100) * 96 * s), 12 * s);

    // Right panel - Ammo & Kills
    ctx.fillStyle = '#0cf';
    ctx.font = `bold ${Math.floor(14 * s)}px monospace`;
    ctx.textAlign = 'right';
    ctx.fillText('PLASMA', SCREEN_W - 15 * s, hudY + 20 * s);
    ctx.fillText('KILLS', SCREEN_W - 100 * s, hudY + 20 * s);

    ctx.fillStyle = currentWeapon === 1 ? '#0cf' : '#446';
    ctx.font = `bold ${Math.floor(28 * s)}px monospace`;
    ctx.fillText(player.ammo, SCREEN_W - 15 * s, hudY + 48 * s);

    ctx.fillStyle = '#f4a';
    ctx.fillText(player.kills, SCREEN_W - 100 * s, hudY + 48 * s);

    // Level indicator
    ctx.fillStyle = '#fa0';
    ctx.font = `bold ${Math.floor(12 * s)}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillText(`LEVEL ${currentLevel}`, SCREEN_W / 2, hudY + 15 * s);

    // Weapon indicator
    ctx.fillStyle = '#5a6a7a';
    ctx.fillText(currentWeapon === 0 ? '[ BATON ]' : '[ RIFLE ]', SCREEN_W / 2, hudY + 55 * s);
}

// Render light sprites
function renderLights() {
    const lightData = lights.map(light => {
        const dx = light.x - player.x;
        const dy = light.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) - player.angle;
        return { light, dist, angle };
    });

    // Sort by distance (far to near)
    lightData.sort((a, b) => b.dist - a.dist);

    for (const { light, dist, angle } of lightData) {
        let normAngle = angle;
        while (normAngle > Math.PI) normAngle -= 2 * Math.PI;
        while (normAngle < -Math.PI) normAngle += 2 * Math.PI;

        if (Math.abs(normAngle) > HALF_FOV + 0.2) continue;

        const screenX = (0.5 + normAngle / FOV) * SCREEN_W;
        const spriteSize = Math.min(SCREEN_H * 0.3, (SCREEN_H * 0.15) / dist);
        const spriteTop = SCREEN_H / 2 - spriteSize * 1.5; // Position higher (wall-mounted)

        // Check depth - only draw if not behind wall
        const col = Math.floor(screenX / SCALE);
        if (col >= 0 && col < NUM_RAYS && depthBuffer[col] < dist) continue;

        // Flicker effect
        const flicker = 0.7 + 0.3 * Math.sin(Date.now() * 0.008 + light.phase);
        const glowSize = spriteSize * (1.5 + 0.2 * Math.sin(Date.now() * 0.005 + light.phase));

        // Outer glow
        const gradient = ctx.createRadialGradient(screenX, spriteTop + spriteSize / 2, 0, screenX, spriteTop + spriteSize / 2, glowSize);
        gradient.addColorStop(0, `rgba(0, 200, 255, ${0.4 * flicker})`);
        gradient.addColorStop(0.4, `rgba(0, 150, 200, ${0.2 * flicker})`);
        gradient.addColorStop(1, 'rgba(0, 100, 150, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(screenX - glowSize, spriteTop + spriteSize / 2 - glowSize, glowSize * 2, glowSize * 2);

        // Light fixture (small rectangle)
        ctx.fillStyle = `rgba(40, 60, 80, ${flicker})`;
        ctx.fillRect(screenX - spriteSize * 0.4, spriteTop, spriteSize * 0.8, spriteSize * 0.5);

        // Bright center
        ctx.fillStyle = `rgba(150, 230, 255, ${flicker})`;
        ctx.fillRect(screenX - spriteSize * 0.25, spriteTop + spriteSize * 0.15, spriteSize * 0.5, spriteSize * 0.25);
    }
}

// Render victory portal sprite at exit location
function renderVictoryPortal() {
    const portalX = ELEVATOR.x + 0.5;
    const portalY = ELEVATOR.y + 0.5;

    const dx = portalX - player.x;
    const dy = portalY - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    let angle = Math.atan2(dy, dx) - player.angle;

    // Normalize angle
    while (angle > Math.PI) angle -= 2 * Math.PI;
    while (angle < -Math.PI) angle += 2 * Math.PI;

    // Skip if behind player or too far to side
    if (Math.abs(angle) > HALF_FOV + 0.3) return;

    const screenX = (0.5 + angle / FOV) * SCREEN_W;
    const spriteHeight = Math.min(SCREEN_H * 1.5, SCREEN_H / dist);
    const spriteWidth = spriteHeight * 0.8;
    const spriteTop = (SCREEN_H - spriteHeight) / 2;

    // Check if behind wall (use center column)
    const col = Math.floor(screenX / SCALE);
    if (col >= 0 && col < NUM_RAYS && depthBuffer[col] < dist) return;

    // Animated pulse
    const time = Date.now() * 0.003;
    const pulse = 0.7 + 0.3 * Math.sin(time);
    const rotationPhase = time * 0.5;

    // Outer glow (large, soft)
    const glowSize = spriteHeight * 1.2;
    const outerGlow = ctx.createRadialGradient(screenX, SCREEN_H / 2, 0, screenX, SCREEN_H / 2, glowSize);
    outerGlow.addColorStop(0, `rgba(100, 255, 150, ${0.4 * pulse})`);
    outerGlow.addColorStop(0.3, `rgba(50, 255, 100, ${0.25 * pulse})`);
    outerGlow.addColorStop(0.6, `rgba(0, 200, 100, ${0.1 * pulse})`);
    outerGlow.addColorStop(1, 'rgba(0, 150, 50, 0)');
    ctx.fillStyle = outerGlow;
    ctx.beginPath();
    ctx.arc(screenX, SCREEN_H / 2, glowSize, 0, Math.PI * 2);
    ctx.fill();

    // Inner portal (bright core)
    const innerSize = spriteHeight * 0.5;
    const innerGlow = ctx.createRadialGradient(screenX, SCREEN_H / 2, 0, screenX, SCREEN_H / 2, innerSize);
    innerGlow.addColorStop(0, `rgba(255, 255, 255, ${0.9 * pulse})`);
    innerGlow.addColorStop(0.3, `rgba(150, 255, 200, ${0.7 * pulse})`);
    innerGlow.addColorStop(0.7, `rgba(50, 255, 150, ${0.4 * pulse})`);
    innerGlow.addColorStop(1, 'rgba(0, 200, 100, 0)');
    ctx.fillStyle = innerGlow;
    ctx.beginPath();
    ctx.arc(screenX, SCREEN_H / 2, innerSize, 0, Math.PI * 2);
    ctx.fill();

    // Rotating energy rings
    ctx.strokeStyle = `rgba(100, 255, 180, ${0.6 * pulse})`;
    ctx.lineWidth = 2;
    for (let i = 0; i < 3; i++) {
        const ringPhase = rotationPhase + (i * Math.PI * 2 / 3);
        const ringSize = spriteHeight * (0.3 + i * 0.15);
        const squeeze = 0.3 + 0.2 * Math.sin(ringPhase);

        ctx.beginPath();
        ctx.ellipse(screenX, SCREEN_H / 2, ringSize, ringSize * squeeze, ringPhase, 0, Math.PI * 2);
        ctx.stroke();
    }

    // Sparkles
    ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
    for (let i = 0; i < 6; i++) {
        const sparkAngle = rotationPhase * 2 + (i * Math.PI / 3);
        const sparkDist = spriteHeight * (0.25 + 0.1 * Math.sin(time * 2 + i));
        const sparkX = screenX + Math.cos(sparkAngle) * sparkDist;
        const sparkY = SCREEN_H / 2 + Math.sin(sparkAngle) * sparkDist * 0.5;
        const sparkSize = 3 + 2 * Math.sin(time * 3 + i);

        ctx.beginPath();
        ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
        ctx.fill();
    }

    // "EXIT" text above portal
    const textY = spriteTop + spriteHeight * 0.1;
    const fontSize = Math.max(12, Math.floor(spriteHeight * 0.12));
    ctx.font = `bold ${fontSize}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillStyle = `rgba(150, 255, 200, ${0.8 + 0.2 * Math.sin(time * 2)})`;
    ctx.fillText('EXIT', screenX, textY);
}

// Render ammo box sprites
function renderAmmoBoxes() {
    const boxData = ammoBoxes.filter(b => !b.collected).map(box => {
        const dx = box.x - player.x;
        const dy = box.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) - player.angle;
        return { box, dist, angle };
    });

    // Sort by distance (far to near)
    boxData.sort((a, b) => b.dist - a.dist);

    for (const { box, dist, angle } of boxData) {
        let normAngle = angle;
        while (normAngle > Math.PI) normAngle -= 2 * Math.PI;
        while (normAngle < -Math.PI) normAngle += 2 * Math.PI;

        if (Math.abs(normAngle) > HALF_FOV + 0.2) continue;

        const screenX = (0.5 + normAngle / FOV) * SCREEN_W;
        const spriteSize = Math.min(SCREEN_H * 0.4, (SCREEN_H * 0.2) / dist);
        const spriteTop = SCREEN_H / 2 + spriteSize * 0.3; // On the floor

        // Check depth - only draw if not behind wall
        const col = Math.floor(screenX / SCALE);
        if (col >= 0 && col < NUM_RAYS && depthBuffer[col] < dist) continue;

        const shade = Math.max(0.3, 1 - dist / MAX_DEPTH);
        const bob = Math.sin(Date.now() * 0.005) * spriteSize * 0.1;

        // Box body (green ammo crate)
        ctx.fillStyle = `rgb(${Math.floor(40 * shade)}, ${Math.floor(120 * shade)}, ${Math.floor(50 * shade)})`;
        ctx.fillRect(screenX - spriteSize * 0.4, spriteTop - spriteSize * 0.6 + bob, spriteSize * 0.8, spriteSize * 0.6);

        // Box highlight
        ctx.fillStyle = `rgb(${Math.floor(60 * shade)}, ${Math.floor(180 * shade)}, ${Math.floor(80 * shade)})`;
        ctx.fillRect(screenX - spriteSize * 0.35, spriteTop - spriteSize * 0.55 + bob, spriteSize * 0.3, spriteSize * 0.15);

        // Ammo symbol (yellow rectangle)
        ctx.fillStyle = `rgb(${Math.floor(220 * shade)}, ${Math.floor(200 * shade)}, ${Math.floor(50 * shade)})`;
        ctx.fillRect(screenX - spriteSize * 0.15, spriteTop - spriteSize * 0.45 + bob, spriteSize * 0.3, spriteSize * 0.25);

        // Glow effect
        const glowSize = spriteSize * 0.8;
        const gradient = ctx.createRadialGradient(screenX, spriteTop - spriteSize * 0.3 + bob, 0, screenX, spriteTop - spriteSize * 0.3 + bob, glowSize);
        gradient.addColorStop(0, `rgba(100, 255, 100, ${0.2 * shade})`);
        gradient.addColorStop(1, 'rgba(50, 200, 50, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(screenX - glowSize, spriteTop - spriteSize * 0.3 - glowSize + bob, glowSize * 2, glowSize * 2);
    }
}

// Render health pack sprites
function renderHealthPacks() {
    const packData = healthPacks.filter(p => !p.collected).map(pack => {
        const dx = pack.x - player.x;
        const dy = pack.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) - player.angle;
        return { pack, dist, angle };
    });

    // Sort by distance (far to near)
    packData.sort((a, b) => b.dist - a.dist);

    for (const { pack, dist, angle } of packData) {
        let normAngle = angle;
        while (normAngle > Math.PI) normAngle -= 2 * Math.PI;
        while (normAngle < -Math.PI) normAngle += 2 * Math.PI;

        if (Math.abs(normAngle) > HALF_FOV + 0.2) continue;

        const screenX = (0.5 + normAngle / FOV) * SCREEN_W;
        const spriteSize = Math.min(SCREEN_H * 0.4, (SCREEN_H * 0.2) / dist);
        const spriteTop = SCREEN_H / 2 + spriteSize * 0.3; // On the floor

        // Check depth - only draw if not behind wall
        const col = Math.floor(screenX / SCALE);
        if (col >= 0 && col < NUM_RAYS && depthBuffer[col] < dist) continue;

        const shade = Math.max(0.3, 1 - dist / MAX_DEPTH);
        const bob = Math.sin(Date.now() * 0.006 + 1) * spriteSize * 0.1;

        // Box body (red/white medical crate)
        ctx.fillStyle = `rgb(${Math.floor(200 * shade)}, ${Math.floor(50 * shade)}, ${Math.floor(50 * shade)})`;
        ctx.fillRect(screenX - spriteSize * 0.4, spriteTop - spriteSize * 0.6 + bob, spriteSize * 0.8, spriteSize * 0.6);

        // White cross (horizontal)
        ctx.fillStyle = `rgb(${Math.floor(255 * shade)}, ${Math.floor(255 * shade)}, ${Math.floor(255 * shade)})`;
        ctx.fillRect(screenX - spriteSize * 0.25, spriteTop - spriteSize * 0.38 + bob, spriteSize * 0.5, spriteSize * 0.15);

        // White cross (vertical)
        ctx.fillRect(screenX - spriteSize * 0.1, spriteTop - spriteSize * 0.52 + bob, spriteSize * 0.2, spriteSize * 0.42);

        // Glow effect
        const glowSize = spriteSize * 0.8;
        const gradient = ctx.createRadialGradient(screenX, spriteTop - spriteSize * 0.3 + bob, 0, screenX, spriteTop - spriteSize * 0.3 + bob, glowSize);
        gradient.addColorStop(0, `rgba(255, 100, 100, ${0.2 * shade})`);
        gradient.addColorStop(1, 'rgba(200, 50, 50, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(screenX - glowSize, spriteTop - spriteSize * 0.3 - glowSize + bob, glowSize * 2, glowSize * 2);
    }
}

// Render plasma ball projectiles
function renderPlasmaBalls() {
    for (const ball of plasmaBalls) {
        if (!ball.alive) continue;

        const dx = ball.x - player.x;
        const dy = ball.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        let angle = Math.atan2(dy, dx) - player.angle;

        while (angle > Math.PI) angle -= 2 * Math.PI;
        while (angle < -Math.PI) angle += 2 * Math.PI;

        if (Math.abs(angle) > HALF_FOV + 0.3) continue;

        const screenX = (0.5 + angle / FOV) * SCREEN_W;
        const spriteSize = Math.min(SCREEN_H * 0.5, (SCREEN_H * 0.15) / dist);

        // Check depth
        const col = Math.floor(screenX / SCALE);
        if (col >= 0 && col < NUM_RAYS && depthBuffer[col] < dist) continue;

        const pulse = 0.7 + 0.3 * Math.sin(Date.now() * 0.02);

        // Outer glow
        const glowSize = spriteSize * 2;
        const gradient = ctx.createRadialGradient(screenX, SCREEN_H / 2, 0, screenX, SCREEN_H / 2, glowSize);
        gradient.addColorStop(0, `rgba(100, 200, 255, ${0.8 * pulse})`);
        gradient.addColorStop(0.3, `rgba(50, 150, 255, ${0.4 * pulse})`);
        gradient.addColorStop(1, 'rgba(0, 100, 200, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(screenX, SCREEN_H / 2, glowSize, 0, Math.PI * 2);
        ctx.fill();

        // Core
        ctx.fillStyle = `rgba(200, 240, 255, ${pulse})`;
        ctx.beginPath();
        ctx.arc(screenX, SCREEN_H / 2, spriteSize * 0.5, 0, Math.PI * 2);
        ctx.fill();

        // Bright center
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(screenX, SCREEN_H / 2, spriteSize * 0.2, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Render enemy sprites
function renderSprites() {
    // Calculate distance and angle for each enemy (include dying enemies)
    const spriteData = enemies.filter(e => e.alive || e.dying).map(enemy => {
        const dx = enemy.x - player.x;
        const dy = enemy.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) - player.angle;
        return { enemy, dist, angle };
    });

    // Sort by distance (far to near)
    spriteData.sort((a, b) => b.dist - a.dist);

    // Render each sprite
    for (const { enemy, dist, angle } of spriteData) {
        // Normalize angle to -PI to PI
        let normAngle = angle;
        while (normAngle > Math.PI) normAngle -= 2 * Math.PI;
        while (normAngle < -Math.PI) normAngle += 2 * Math.PI;

        // Skip if behind player or too far to side
        if (Math.abs(normAngle) > HALF_FOV + 0.3) continue;

        // Screen position
        const screenX = (0.5 + normAngle / FOV) * SCREEN_W;

        // Death animation parameters
        const deathProgress = enemy.dying ? enemy.deathTimer / 30 : 0; // 30 frames to die
        const collapse = deathProgress; // 0 to 1
        const tilt = deathProgress * 0.5; // Tilt/lean as they fall

        // Sprite size based on distance (shrink vertically when dying)
        const baseHeight = Math.min(SCREEN_H * 1.2, SCREEN_H / dist);
        const spriteHeight = baseHeight * (1 - collapse * 0.7);
        const spriteWidth = baseHeight * 0.6 * (1 + collapse * 0.3); // Spread out as they fall
        const spriteTop = (SCREEN_H - baseHeight) / 2 + (baseHeight - spriteHeight);

        // Draw sprite column by column (for proper depth testing)
        const startCol = Math.floor((screenX - spriteWidth / 2) / SCALE);
        const endCol = Math.floor((screenX + spriteWidth / 2) / SCALE);

        let visibleOnScreen = false;

        for (let col = startCol; col <= endCol; col++) {
            if (col < 0 || col >= NUM_RAYS) continue;
            if (depthBuffer[col] < dist) continue; // Behind wall

            // Enemy is visible (not behind wall)
            visibleOnScreen = true;

            const spriteX = col * SCALE;
            const colRatio = (col - startCol) / (endCol - startCol);

            // Draw enemy as alien creature
            const shade = Math.max(0.3, 1 - dist / MAX_DEPTH);

            // Body color (purple/magenta alien, turns darker when dying)
            const deathColor = enemy.dying ? collapse : 0;
            const r = Math.floor((120 + 60 * Math.sin(colRatio * Math.PI)) * shade * (1 - deathColor * 0.5));
            const g = Math.floor((40 - 20 * deathColor) * shade);
            const b = Math.floor((160 + 40 * Math.sin(colRatio * Math.PI * 2)) * shade * (1 - deathColor * 0.3));

            // Draw column of sprite with death deformation
            let colHeight = spriteHeight * getEnemyShape(colRatio);

            // Add wobble/collapse effect when dying
            if (enemy.dying) {
                const wobble = Math.sin(colRatio * Math.PI * 4 + enemy.deathTimer * 0.3) * collapse * 10;
                colHeight *= (1 - Math.abs(colRatio - 0.5) * collapse);
            }

            const colTop = spriteTop + (spriteHeight - colHeight);

            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect(spriteX, colTop, SCALE + 1, colHeight);

            // Glowing cyan eyes (in upper portion) - fade out when dying
            if (!enemy.dying && (colRatio > 0.25 && colRatio < 0.4 || colRatio > 0.6 && colRatio < 0.75)) {
                const eyeY = spriteTop + spriteHeight * 0.2;
                const eyeSize = spriteHeight * 0.08;
                ctx.fillStyle = `rgb(0, ${Math.floor(255 * shade)}, ${Math.floor(255 * shade)})`;
                ctx.fillRect(spriteX, eyeY, SCALE + 1, eyeSize);
            }

            // Alien markings/patterns
            if (!enemy.dying && colRatio > 0.3 && colRatio < 0.7 && (col % 4 === 0)) {
                const markY = spriteTop + spriteHeight * 0.5;
                const markSize = spriteHeight * 0.15;
                ctx.fillStyle = `rgba(0, 255, 200, ${0.3 * shade})`;
                ctx.fillRect(spriteX, markY, SCALE + 1, markSize);
            }
        }

        // Mark enemy as seen if any part was visible on screen
        if (visibleOnScreen && !enemy.seen) {
            enemy.seen = true;
            playEnemyRoarSound();
        }
    }
}

// Enemy shape function (returns height multiplier based on column position)
function getEnemyShape(t) {
    // Creates an alien silhouette
    if (t < 0.1 || t > 0.9) return 0.3; // Thin appendages
    if (t < 0.2 || t > 0.8) return 0.5; // Arms
    if (t < 0.3 || t > 0.7) return 0.75; // Shoulders
    return 0.85 + Math.sin(t * Math.PI) * 0.15; // Body/head bulge
}

// Fire plasma ball (secondary fire - right click)
function firePlasmaBall() {
    if (currentWeapon !== 1) return; // Only works with plasma gun equipped
    if (plasmaballCooldown > 0) return;
    if (player.ammo < 10) {
        playEmptyClickSound();
        plasmaballCooldown = 15; // Brief cooldown to prevent click spam
        return;
    }

    player.ammo -= 10;
    plasmaballCooldown = 60; // 1 second cooldown
    playPlasmaBallSound();
    muzzleFlash = 1;

    plasmaBalls.push({
        x: player.x,
        y: player.y,
        angle: player.angle,
        speed: 0.15,
        radius: 0.4, // Collision radius for damaging enemies
        alive: true
    });
}

// Update plasma balls
function updatePlasmaBalls() {
    if (plasmaballCooldown > 0) plasmaballCooldown--;

    for (const ball of plasmaBalls) {
        if (!ball.alive) continue;

        // Move the ball
        ball.x += Math.cos(ball.angle) * ball.speed;
        ball.y += Math.sin(ball.angle) * ball.speed;

        // Check wall collision
        if (isWall(ball.x, ball.y)) {
            ball.alive = false;
            continue;
        }

        // Check enemy collisions
        let centerHit = false;
        for (const enemy of enemies) {
            if (!enemy.alive) continue;

            const dx = enemy.x - ball.x;
            const dy = enemy.y - ball.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Damage enemies within radius
            if (dist < ball.radius + 0.3) {
                enemy.health -= 30;
                if (enemy.health <= 0 && !enemy.dying) {
                    enemy.alive = false;
                    enemy.dying = true;
                    enemy.deathTimer = 0;
                    player.kills++;
                    playEnemyDeathSound();
                } else if (enemy.alive) {
                    playEnemyHitSound();
                }

                // Center hit - destroy the ball
                if (dist < 0.3) {
                    centerHit = true;
                }
            }
        }

        if (centerHit) {
            ball.alive = false;
        }
    }

    // Remove dead plasma balls
    for (let i = plasmaBalls.length - 1; i >= 0; i--) {
        if (!plasmaBalls[i].alive) {
            plasmaBalls.splice(i, 1);
        }
    }
}

// Attack function (handles both melee and ranged)
function attack() {
    if (shootCooldown > 0) return;

    if (currentWeapon === 0) {
        // Baton (melee) - one-hit kill, 3 second cooldown, short range
        shootCooldown = 180; // 3 seconds at 60fps
        swingAnimation = 20;
        playHammerSound();

        // Check if any enemy is in melee range
        const hitEnemy = enemies.find(enemy => {
            if (!enemy.alive) return false;

            const dx = enemy.x - player.x;
            const dy = enemy.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            let angle = Math.atan2(dy, dx) - player.angle;

            while (angle > Math.PI) angle -= 2 * Math.PI;
            while (angle < -Math.PI) angle += 2 * Math.PI;

            // Melee range: close distance, wider angle
            return dist < 1.5 && Math.abs(angle) < 0.5;
        });

        if (hitEnemy) {
            // Baton always one-hit kills regardless of enemy health
            hitEnemy.health = 0;
            hitEnemy.alive = false;
            hitEnemy.dying = true;
            hitEnemy.deathTimer = 0;
            player.kills++;
            playEnemyDeathSound();
        }
    } else {
        // Gun (ranged) - uses ammo
        if (player.ammo <= 0) {
            playEmptyClickSound();
            shootCooldown = 15; // Brief cooldown to prevent click spam
            return;
        }

        player.ammo--;
        shootCooldown = 15;
        muzzleFlash = 1;
        playGunSound();

        // Check if any enemy is in crosshairs
        const hitEnemy = enemies.find(enemy => {
            if (!enemy.alive) return false;

            const dx = enemy.x - player.x;
            const dy = enemy.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            let angle = Math.atan2(dy, dx) - player.angle;

            while (angle > Math.PI) angle -= 2 * Math.PI;
            while (angle < -Math.PI) angle += 2 * Math.PI;

            // Check if in crosshair and not behind wall
            const screenX = (0.5 + angle / FOV) * SCREEN_W;
            const col = Math.floor(screenX / SCALE);
            if (col < 0 || col >= NUM_RAYS) return false;

            return Math.abs(angle) < 0.1 && depthBuffer[col] >= dist;
        });

        if (hitEnemy) {
            hitEnemy.health -= 15;
            if (hitEnemy.health <= 0 && !hitEnemy.dying) {
                hitEnemy.alive = false;
                hitEnemy.dying = true;
                hitEnemy.deathTimer = 0;
                player.kills++;
                playEnemyDeathSound();
            } else {
                playEnemyHitSound();
            }
        }
    }
}

// Update enemies (AI)
function updateEnemies() {
    for (const enemy of enemies) {
        // Progress death animation
        if (enemy.dying) {
            enemy.deathTimer++;
            if (enemy.deathTimer >= 30) {
                enemy.dying = false; // Animation complete, fully dead
            }
            continue;
        }

        if (!enemy.alive) continue;
        if (!enemy.seen) continue; // Don't move until player has seen this enemy

        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // Move toward player if close enough
        if (dist < 10 && dist > 0.5) {
            const moveX = (dx / dist) * enemy.speed;
            const moveY = (dy / dist) * enemy.speed;

            const newX = enemy.x + moveX;
            const newY = enemy.y + moveY;

            if (!isWall(newX, enemy.y)) enemy.x = newX;
            if (!isWall(enemy.x, newY)) enemy.y = newY;
        }

        // Damage player if very close (max once per second per enemy)
        // Damage scales with level: 5 * currentLevel
        if (dist < 0.6) {
            const now = Date.now();
            if (!enemy.lastHitTime || now - enemy.lastHitTime >= 1000) {
                player.health -= 5 * currentLevel;
                headDamageFlash = 10;
                damageFlash = 1;
                playPlayerHitSound();
                enemy.lastHitTime = now;
            }
        }
    }
}

// Check for ammo box pickups
function checkAmmoPickups() {
    for (const box of ammoBoxes) {
        if (box.collected) continue;

        const dx = box.x - player.x;
        const dy = box.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 0.5) {
            box.collected = true;
            player.ammo += 15;
            playAmmoPickupSound();
        }
    }
}

// Check for health pack pickups
function checkHealthPickups() {
    for (const pack of healthPacks) {
        if (pack.collected) continue;
        if (player.health >= 100) continue; // Only pick up if damaged

        const dx = pack.x - player.x;
        const dy = pack.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 0.5) {
            pack.collected = true;
            player.health = Math.min(100, player.health + 25);
            playHealthPickupSound();
        }
    }
}

// Update UI (now handled by renderHUD)
function updateUI() {
    // HUD is now rendered on canvas
}

// Render minimap
function renderMinimap() {
    const scale = minimap.width / MAP_W;
    minimapCtx.fillStyle = '#0a0a12';
    minimapCtx.fillRect(0, 0, minimap.width, minimap.height);

    for (let y = 0; y < MAP_H; y++) {
        for (let x = 0; x < MAP_W; x++) {
            const tile = MAP[y][x];
            if (tile === 1) {
                // Spaceship walls - blue-gray
                minimapCtx.fillStyle = '#3a4555';
            } else if (tile === 2) {
                const door = getDoor(x, y);
                // Metallic door: grey when closed, fades when open
                const openness = door ? door.state : 0;
                const r = Math.floor(120 * (1 - openness) + 20 * openness);
                const g = Math.floor(125 * (1 - openness) + 20 * openness);
                const b = Math.floor(135 * (1 - openness) + 20 * openness);
                minimapCtx.fillStyle = `rgb(${r},${g},${b})`;
            } else if (tile === 3) {
                // Escape elevator door: green when closed, fades when open
                const door = getDoor(x, y);
                const openness = door ? door.state : 0;
                const r = Math.floor(30 * (1 - openness) + 20 * openness);
                const g = Math.floor(200 * (1 - openness) + 20 * openness);
                const b = Math.floor(60 * (1 - openness) + 20 * openness);
                minimapCtx.fillStyle = `rgb(${r},${g},${b})`;
            } else if (tile === 4) {
                // Exit portal: pulsing bright green
                const pulse = 0.7 + 0.3 * Math.sin(Date.now() * 0.005);
                const g = Math.floor(200 + 55 * pulse);
                minimapCtx.fillStyle = `rgb(50, ${g}, 100)`;
            } else {
                // Floor - dark blue
                minimapCtx.fillStyle = '#151820';
            }
            minimapCtx.fillRect(x * scale, y * scale, scale - 1, scale - 1);
        }
    }

    // Player - cyan
    minimapCtx.fillStyle = '#0ff';
    minimapCtx.beginPath();
    minimapCtx.arc(player.x * scale, player.y * scale, 3, 0, Math.PI * 2);
    minimapCtx.fill();

    // Direction - cyan
    minimapCtx.strokeStyle = '#0ff';
    minimapCtx.beginPath();
    minimapCtx.moveTo(player.x * scale, player.y * scale);
    minimapCtx.lineTo(
        player.x * scale + Math.cos(player.angle) * 15,
        player.y * scale + Math.sin(player.angle) * 15
    );
    minimapCtx.stroke();

    // Enemies - magenta/purple (aliens)
    for (const enemy of enemies) {
        if (!enemy.alive && !enemy.dying) continue;
        // Fade out dying enemies
        const alpha = enemy.dying ? 1 - enemy.deathTimer / 30 : 1;
        minimapCtx.fillStyle = enemy.dying ? `rgba(80, 40, 80, ${alpha})` : '#c4f';
        minimapCtx.beginPath();
        minimapCtx.arc(enemy.x * scale, enemy.y * scale, 3, 0, Math.PI * 2);
        minimapCtx.fill();
    }

    // Ammo boxes - green
    for (const box of ammoBoxes) {
        if (box.collected) continue;
        minimapCtx.fillStyle = '#4f4';
        minimapCtx.fillRect(box.x * scale - 2, box.y * scale - 2, 4, 4);
    }

    // Health packs - red
    for (const pack of healthPacks) {
        if (pack.collected) continue;
        minimapCtx.fillStyle = '#f44';
        minimapCtx.fillRect(pack.x * scale - 2, pack.y * scale - 2, 4, 4);
    }
}

// Handle input
function handleInput() {
    // Mouse movement is applied directly in the mousemove event handler

    const cos = Math.cos(player.angle);
    const sin = Math.sin(player.angle);

    let newX = player.x;
    let newY = player.y;

    // Keyboard input
    if (keys['KeyW']) { newX += cos * player.speed; newY += sin * player.speed; }
    if (keys['KeyS']) { newX -= cos * player.speed; newY -= sin * player.speed; }
    if (keys['KeyA']) { newX += sin * player.speed; newY -= cos * player.speed; }
    if (keys['KeyD']) { newX -= sin * player.speed; newY += cos * player.speed; }
    if (keys['ArrowLeft']) rawMouseAngle -= player.rotSpeed / MOUSE_SENSITIVITY;
    if (keys['ArrowRight']) rawMouseAngle += player.rotSpeed / MOUSE_SENSITIVITY;
    player.angle = rawMouseAngle * MOUSE_SENSITIVITY;

    // Touch joystick input (forward/back is -dy, strafe is dx)
    if (touchState.joystick.active) {
        const jx = touchState.joystick.dx;
        const jy = -touchState.joystick.dy; // Invert Y so up = forward
        // Forward/backward
        newX += cos * player.speed * jy;
        newY += sin * player.speed * jy;
        // Strafe left/right
        newX -= sin * player.speed * jx;
        newY += cos * player.speed * jx;
    }

    // Collision detection with sliding
    const margin = 0.2;
    if (!isWall(newX + margin, player.y) && !isWall(newX - margin, player.y)) {
        player.x = newX;
    }
    if (!isWall(player.x, newY + margin) && !isWall(player.x, newY - margin)) {
        player.y = newY;
    }
}

// Game loop
function gameLoop(currentTime) {
    // Frame rate limiting
    const elapsed = currentTime - lastFrameTime;
    if (elapsed < FRAME_TIME) {
        requestAnimationFrame(gameLoop);
        return;
    }
    lastFrameTime = currentTime - (elapsed % FRAME_TIME); // Adjust for drift

    // Handle game over state
    if (player.health <= 0) {
        gameState = 'gameover';
    }

    // Handle victory state
    if (gameState === 'playing' && isInElevator()) {
        gameState = 'victory';
        playVictoryMusic();
    }

    // Show end screens
    if (gameState === 'gameover') {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);
        ctx.fillStyle = '#f00';
        ctx.font = '48px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', SCREEN_W / 2, SCREEN_H / 2);
        ctx.font = '24px monospace';
        ctx.fillText(`Kills: ${player.kills}`, SCREEN_W / 2, SCREEN_H / 2 + 40);
        ctx.fillStyle = '#888';
        ctx.fillText('Press SPACE or click to restart', SCREEN_W / 2, SCREEN_H / 2 + 80);
        requestAnimationFrame(gameLoop);
        return;
    }

    if (gameState === 'victory') {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);
        ctx.fillStyle = '#0ff';
        ctx.font = '48px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`LEVEL ${currentLevel} COMPLETE!`, SCREEN_W / 2, SCREEN_H / 2 - 20);
        ctx.fillStyle = '#0f0';
        ctx.font = '24px monospace';
        ctx.fillText(`Kills: ${player.kills}`, SCREEN_W / 2, SCREEN_H / 2 + 25);
        ctx.fillStyle = '#fa0';
        ctx.fillText(`Health: ${Math.floor(player.health)} | Ammo: ${player.ammo}`, SCREEN_W / 2, SCREEN_H / 2 + 60);
        ctx.fillStyle = '#888';
        ctx.fillText('Press SPACE or click for next level', SCREEN_W / 2, SCREEN_H / 2 + 100);
        requestAnimationFrame(gameLoop);
        return;
    }

    handleInput();

    // Attack
    if (keys['Space']) attack();
    if (shootCooldown > 0) shootCooldown--;

    // Open doors
    if (keys['KeyE']) {
        tryOpenDoor();
        keys['KeyE'] = false; // Prevent holding E from spamming
    }

    updateDoors();
    updateEnemies();
    updatePlasmaBalls();
    checkAmmoPickups();
    checkHealthPickups();
    render3D();
    renderMinimap();
    updateUI();

    requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
