<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Station Escape</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            background: #050810;
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        #game {
            display: block;
            cursor: none;
        }
        #minimap {
            position: absolute;
            top: 10px;
            right: 10px;
            border: 2px solid #2a4060;
            box-shadow: 0 0 10px rgba(0, 150, 200, 0.3);
        }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #5a8aaa;
            font-size: 12px;
            text-shadow: 0 0 5px rgba(0, 150, 200, 0.3);
        }
        /* Touch controls */
        #touch-controls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            pointer-events: none;
            z-index: 100;
            background: rgba(5, 8, 16, 0.95);
            border-top: 2px solid #2a4060;
        }
        .touch-btn {
            position: absolute;
            background: rgba(0, 150, 200, 0.3);
            border: 2px solid rgba(0, 200, 255, 0.5);
            border-radius: 50%;
            color: #0cf;
            font-family: monospace;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        .touch-btn:active {
            background: rgba(0, 200, 255, 0.5);
        }
        .joystick-zone {
            position: absolute;
            bottom: 10%;
            width: 35%;
            max-width: 120px;
            aspect-ratio: 1;
            background: rgba(0, 100, 150, 0.2);
            border: 2px solid rgba(0, 200, 255, 0.3);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
        }
        #joystick-move {
            left: 5%;
        }
        #joystick-look {
            right: 5%;
        }
        .joystick-knob {
            position: absolute;
            width: 50%;
            height: 50%;
            background: rgba(0, 200, 255, 0.4);
            border: 2px solid rgba(0, 255, 255, 0.6);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #btn-weapon {
            position: absolute;
            bottom: 25%;
            left: 50%;
            transform: translateX(-50%);
            width: 18%;
            max-width: 60px;
            aspect-ratio: 1;
            font-size: 10px;
        }
        @media (pointer: coarse), (max-width: 1024px) {
            #touch-controls { display: block; }
            #instructions { display: none; }
            #crosshair { display: none; }
            #minimap {
                top: 5px;
                right: 5px;
                width: 80px;
                height: 80px;
            }
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <canvas id="minimap" width="160" height="160"></canvas>
    <div id="ui" style="display:none;"><span id="health">Health: 100</span> | <span id="ammo">Ammo: 50</span> | <span id="kills">Kills: 0</span> | <span id="weapon">Weapon: Gun</span></div>
    <div id="instructions">WASD: Move | Mouse: Look | Click: Attack | Right-Click: Plasma Ball (10 ammo) | 1: Baton | 2: Rifle | E: Door | Find KEY to unlock exit</div>
    <div id="crosshair" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#0ff;font-size:24px;pointer-events:none;text-shadow:0 0 10px #0ff;">+</div>
    <!-- Touch controls for mobile -->
    <div id="touch-controls">
        <div id="joystick-move" class="joystick-zone">
            <div id="move-knob" class="joystick-knob"></div>
        </div>
        <div id="btn-weapon" class="touch-btn">WPN</div>
        <div id="joystick-look" class="joystick-zone">
            <div id="look-knob" class="joystick-knob"></div>
        </div>
    </div>
    <script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const minimap = document.getElementById('minimap');
const minimapCtx = minimap.getContext('2d');

// Dynamic screen dimensions
let SCREEN_W = 800;
let SCREEN_H = 600;
const FOV = Math.PI / 3;
const HALF_FOV = FOV / 2;
let NUM_RAYS = 320;
const MAX_DEPTH = 20;
let SCALE = SCREEN_W / NUM_RAYS;
let depthBuffer = new Array(NUM_RAYS);

// Check if touch device
const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

// Resize canvas to fit screen with 4:3 aspect ratio
function resizeCanvas() {
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    // Reserve bottom quarter for controls on touch devices
    const controlsHeight = isTouchDevice ? Math.floor(windowHeight * 0.25) : 0;
    const availableHeight = windowHeight - controlsHeight;

    // Calculate largest 4:3 rectangle that fits in available space
    const targetRatio = 4 / 3;
    const availableRatio = windowWidth / availableHeight;

    let width, height;
    if (availableRatio > targetRatio) {
        // Available area is wider than 4:3, constrain by height
        height = availableHeight;
        width = height * targetRatio;
    } else {
        // Available area is taller than 4:3, constrain by width
        width = windowWidth;
        height = width / targetRatio;
    }

    canvas.width = width;
    canvas.height = height;

    // Set CSS size to match (prevents stretching)
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';

    // Center the canvas horizontally, position at top of available area
    canvas.style.position = 'absolute';
    canvas.style.left = ((windowWidth - width) / 2) + 'px';
    canvas.style.top = ((availableHeight - height) / 2) + 'px';

    SCREEN_W = width;
    SCREEN_H = height;

    // Adjust ray count based on width for performance
    NUM_RAYS = Math.min(640, Math.max(200, Math.floor(width / 2)));
    SCALE = SCREEN_W / NUM_RAYS;

    // Resize depth buffer
    depthBuffer = new Array(NUM_RAYS);

    // Position touch controls in bottom quarter
    if (isTouchDevice) {
        const touchControls = document.getElementById('touch-controls');
        touchControls.style.top = (windowHeight - controlsHeight) + 'px';
        touchControls.style.height = controlsHeight + 'px';
        touchControls.style.bottom = 'auto';
    }
}

// Initial resize
resizeCanvas();

// Resize on window change
window.addEventListener('resize', resizeCanvas);

// Map: 1 = wall, 0 = empty, 2 = door, 3 = locked door, 4 = exit portal
const MAP_W = 24;
const MAP_H = 24;
const MAP = [];
const ELEVATOR = { x: 0, y: 0 };
const doors = [];
let playerStart = { x: 1.5, y: 1.5 };
let enemies = [];
let roomCenters = []; // Track room centers for light placement

// Key system
let levelKey = { x: 0, y: 0, collected: false };
let hasKey = false;

// Level color theme system
let levelTheme = {};

function generateLevelTheme() {
    // Base hue for the level (0-360)
    const baseHue = Math.random() * 360;

    // Color variation styles
    const styles = ['cool', 'warm', 'alien', 'industrial', 'organic'];
    const style = styles[Math.floor(Math.random() * styles.length)];

    let wallHue, accentHue, lightHue;

    switch (style) {
        case 'cool':
            wallHue = 200 + Math.random() * 40; // Blue range
            accentHue = 180 + Math.random() * 60; // Cyan-blue
            lightHue = 180 + Math.random() * 30; // Cyan
            break;
        case 'warm':
            wallHue = 20 + Math.random() * 30; // Orange-brown
            accentHue = 30 + Math.random() * 30; // Orange-yellow
            lightHue = 40 + Math.random() * 20; // Yellow-orange
            break;
        case 'alien':
            wallHue = 270 + Math.random() * 60; // Purple-magenta
            accentHue = 300 + Math.random() * 40; // Magenta-pink
            lightHue = 280 + Math.random() * 40; // Purple
            break;
        case 'industrial':
            wallHue = 40 + Math.random() * 20; // Yellow-green (rust)
            accentHue = 60 + Math.random() * 30; // Green-yellow
            lightHue = 80 + Math.random() * 40; // Green
            break;
        case 'organic':
            wallHue = 140 + Math.random() * 40; // Green
            accentHue = 160 + Math.random() * 40; // Teal-green
            lightHue = 120 + Math.random() * 60; // Green range
            break;
    }

    // Wall saturation and lightness
    const wallSat = 15 + Math.random() * 25; // 15-40% saturation (muted)
    const wallLight = 20 + Math.random() * 15; // 20-35% lightness (dark)

    // Door variation
    const doorSat = 10 + Math.random() * 20;
    const doorLight = 35 + Math.random() * 15;

    // Light brightness
    const lightSat = 60 + Math.random() * 40;
    const lightLight = 50 + Math.random() * 20;

    // Enemy color variations - contrasting with environment
    const enemyStyles = ['demon', 'reptile', 'void', 'toxic', 'fire'];
    const enemyStyle = enemyStyles[Math.floor(Math.random() * enemyStyles.length)];

    let enemyHue, enemySat, enemyLight, enemyEyeHue;

    switch (enemyStyle) {
        case 'demon':
            enemyHue = 280 + Math.random() * 40; // Purple/magenta
            enemySat = 50 + Math.random() * 30;
            enemyLight = 35 + Math.random() * 15;
            enemyEyeHue = 180; // Cyan eyes
            break;
        case 'reptile':
            enemyHue = 100 + Math.random() * 40; // Green
            enemySat = 40 + Math.random() * 30;
            enemyLight = 30 + Math.random() * 15;
            enemyEyeHue = 0; // Red eyes
            break;
        case 'void':
            enemyHue = 220 + Math.random() * 30; // Dark blue
            enemySat = 30 + Math.random() * 20;
            enemyLight = 20 + Math.random() * 15;
            enemyEyeHue = 60; // Yellow eyes
            break;
        case 'toxic':
            enemyHue = 70 + Math.random() * 30; // Yellow-green
            enemySat = 60 + Math.random() * 30;
            enemyLight = 35 + Math.random() * 15;
            enemyEyeHue = 300; // Magenta eyes
            break;
        case 'fire':
            enemyHue = 10 + Math.random() * 30; // Red-orange
            enemySat = 60 + Math.random() * 30;
            enemyLight = 35 + Math.random() * 15;
            enemyEyeHue = 50; // Yellow-orange eyes
            break;
    }

    levelTheme = {
        style,
        // Wall colors (HSL values)
        wallHue,
        wallSat,
        wallLight,
        // Door colors
        doorHue: wallHue + (Math.random() - 0.5) * 30,
        doorSat,
        doorLight,
        // Accent/light colors
        accentHue,
        lightHue,
        lightSat,
        lightLight,
        // Ceiling gradient colors
        ceilDark: `hsl(${wallHue}, ${wallSat * 0.5}%, ${wallLight * 0.4}%)`,
        ceilMid: `hsl(${wallHue}, ${wallSat * 0.6}%, ${wallLight * 0.5}%)`,
        ceilLight: `hsl(${wallHue}, ${wallSat * 0.7}%, ${wallLight * 0.7}%)`,
        // Floor gradient colors
        floorDark: `hsl(${wallHue}, ${wallSat * 0.3}%, ${wallLight * 0.4}%)`,
        floorMid: `hsl(${wallHue}, ${wallSat * 0.4}%, ${wallLight * 0.6}%)`,
        floorLight: `hsl(${wallHue}, ${wallSat * 0.5}%, ${wallLight * 0.8}%)`,
        // Ceiling strip colors
        stripDark: `hsl(${accentHue}, ${wallSat}%, ${wallLight * 1.5}%)`,
        stripLight: `hsl(${accentHue}, ${lightSat * 0.6}%, ${lightLight * 0.8}%)`,
        // Light glow color (RGB for gradients)
        lightR: Math.floor(128 + 127 * Math.cos(lightHue * Math.PI / 180)),
        lightG: Math.floor(128 + 127 * Math.cos((lightHue - 120) * Math.PI / 180)),
        lightB: Math.floor(128 + 127 * Math.cos((lightHue - 240) * Math.PI / 180)),
        // Enemy colors
        enemyStyle,
        enemyHue,
        enemySat,
        enemyLight,
        enemyEyeHue,
        // Enemy shape (randomized independently from color)
        enemyShape: ['humanoid', 'blob', 'insectoid', 'tall', 'squat', 'spider'][Math.floor(Math.random() * 6)],
    };

    return levelTheme;
}

// Helper to convert HSL to RGB for wall rendering
function hslToRgb(h, s, l) {
    s /= 100;
    l /= 100;
    const k = n => (n + h / 30) % 12;
    const a = s * Math.min(l, 1 - l);
    const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
    return [Math.floor(f(0) * 255), Math.floor(f(8) * 255), Math.floor(f(4) * 255)];
}

// Generate initial theme
generateLevelTheme();

// Update crosshair color to match theme
function updateCrosshairColor() {
    const crosshair = document.getElementById('crosshair');
    if (crosshair) {
        const color = `rgb(${levelTheme.lightR}, ${levelTheme.lightG}, ${levelTheme.lightB})`;
        crosshair.style.color = color;
        crosshair.style.textShadow = `0 0 10px ${color}`;
    }
}

// Apply initial crosshair color after DOM loads
setTimeout(updateCrosshairColor, 0);

// Room templates (sized for 24x24 map)
const ROOM_TEMPLATES = {
    // Large room (5x5) - good for arenas
    large: {
        width: 5,
        height: 5,
        lightsInCorners: true,
        enemySpots: 2
    },
    // Medium room (4x4)
    medium: {
        width: 4,
        height: 4,
        lightsInCorners: false,
        enemySpots: 1
    },
    // Small room (3x3)
    small: {
        width: 3,
        height: 3,
        lightsInCorners: false,
        enemySpots: 1
    }
};

// Carve a rectangular room into the map
function carveRoom(x, y, width, height) {
    const tiles = [];
    for (let dy = 0; dy < height; dy++) {
        for (let dx = 0; dx < width; dx++) {
            const tx = x + dx;
            const ty = y + dy;
            if (tx > 0 && tx < MAP_W - 1 && ty > 0 && ty < MAP_H - 1) {
                MAP[ty][tx] = 0;
                tiles.push({ x: tx, y: ty });
            }
        }
    }
    return tiles;
}

// Carve a narrow corridor between two points (1 tile wide)
function carveCorridor(x1, y1, x2, y2) {
    const tiles = [];
    let x = x1, y = y1;

    // Randomly decide to go horizontal or vertical first
    const horizontalFirst = Math.random() < 0.5;

    if (horizontalFirst) {
        // Horizontal then vertical
        while (x !== x2) {
            x += x < x2 ? 1 : -1;
            if (x > 0 && x < MAP_W - 1 && y > 0 && y < MAP_H - 1) {
                if (MAP[y][x] === 1) tiles.push({ x, y });
                MAP[y][x] = 0;
            }
        }
        while (y !== y2) {
            y += y < y2 ? 1 : -1;
            if (x > 0 && x < MAP_W - 1 && y > 0 && y < MAP_H - 1) {
                if (MAP[y][x] === 1) tiles.push({ x, y });
                MAP[y][x] = 0;
            }
        }
    } else {
        // Vertical then horizontal
        while (y !== y2) {
            y += y < y2 ? 1 : -1;
            if (x > 0 && x < MAP_W - 1 && y > 0 && y < MAP_H - 1) {
                if (MAP[y][x] === 1) tiles.push({ x, y });
                MAP[y][x] = 0;
            }
        }
        while (x !== x2) {
            x += x < x2 ? 1 : -1;
            if (x > 0 && x < MAP_W - 1 && y > 0 && y < MAP_H - 1) {
                if (MAP[y][x] === 1) tiles.push({ x, y });
                MAP[y][x] = 0;
            }
        }
    }
    return tiles;
}

// Check if a room can be placed without overlapping existing rooms (with margin)
function canPlaceRoom(x, y, width, height, margin = 2) {
    for (let dy = -margin; dy < height + margin; dy++) {
        for (let dx = -margin; dx < width + margin; dx++) {
            const tx = x + dx;
            const ty = y + dy;
            if (tx <= 0 || tx >= MAP_W - 1 || ty <= 0 || ty >= MAP_H - 1) {
                return false;
            }
            if (dx >= 0 && dx < width && dy >= 0 && dy < height) {
                // Inside room - must be wall
                if (MAP[ty][tx] !== 1) return false;
            }
        }
    }
    return true;
}

// Generate random map with rooms and corridors
function generateMap() {
    // Fill with walls
    for (let y = 0; y < MAP_H; y++) {
        MAP[y] = [];
        for (let x = 0; x < MAP_W; x++) {
            MAP[y][x] = 1;
        }
    }

    roomCenters = [];
    const allTiles = [];

    // Place rooms
    const numRooms = 4 + Math.floor(Math.random() * 3); // 4-6 rooms for 24x24 map
    const rooms = [];

    for (let i = 0; i < numRooms; i++) {
        // Pick a random room template
        const templateNames = Object.keys(ROOM_TEMPLATES);
        // Mix of large and medium rooms with some small ones
        const weights = [2, 3, 2]; // large, medium, small
        const totalWeight = weights.reduce((a, b) => a + b, 0);
        let r = Math.random() * totalWeight;
        let templateIdx = 0;
        for (let j = 0; j < weights.length; j++) {
            r -= weights[j];
            if (r <= 0) {
                templateIdx = j;
                break;
            }
        }
        const templateName = templateNames[templateIdx];
        const template = ROOM_TEMPLATES[templateName];

        // Try to place the room
        let placed = false;
        for (let attempt = 0; attempt < 50 && !placed; attempt++) {
            const x = 3 + Math.floor(Math.random() * (MAP_W - template.width - 6));
            const y = 3 + Math.floor(Math.random() * (MAP_H - template.height - 6));

            if (canPlaceRoom(x, y, template.width, template.height)) {
                const tiles = carveRoom(x, y, template.width, template.height);
                allTiles.push(...tiles);

                const centerX = x + Math.floor(template.width / 2);
                const centerY = y + Math.floor(template.height / 2);

                rooms.push({
                    x, y,
                    width: template.width,
                    height: template.height,
                    centerX,
                    centerY,
                    template: templateName,
                    lightsInCorners: template.lightsInCorners,
                    enemySpots: template.enemySpots
                });

                roomCenters.push({ x: centerX, y: centerY, template: templateName });
                placed = true;
            }
        }
    }

    // Connect rooms with corridors
    // Sort rooms by position for more interesting connections
    rooms.sort((a, b) => (a.centerX + a.centerY) - (b.centerX + b.centerY));

    for (let i = 0; i < rooms.length - 1; i++) {
        const room1 = rooms[i];
        const room2 = rooms[i + 1];
        const corridorTiles = carveCorridor(
            room1.centerX, room1.centerY,
            room2.centerX, room2.centerY
        );
        allTiles.push(...corridorTiles);
    }

    // Add some extra random connections for loops
    const numExtraCorridors = 1 + Math.floor(Math.random() * 2); // 1-2 extra corridors for 24x24
    for (let i = 0; i < numExtraCorridors; i++) {
        const room1 = rooms[Math.floor(Math.random() * rooms.length)];
        const room2 = rooms[Math.floor(Math.random() * rooms.length)];
        if (room1 !== room2) {
            const corridorTiles = carveCorridor(
                room1.centerX, room1.centerY,
                room2.centerX, room2.centerY
            );
            allTiles.push(...corridorTiles);
        }
    }

    // Place player start in a room near the top-left
    const startRoom = rooms.reduce((best, room) => {
        const dist = room.centerX + room.centerY;
        const bestDist = best.centerX + best.centerY;
        return dist < bestDist ? room : best;
    });
    playerStart = { x: startRoom.centerX + 0.5, y: startRoom.centerY + 0.5 };

    // Place exit in a room far from start
    const exitRoom = rooms.reduce((best, room) => {
        const dist = Math.abs(room.centerX - startRoom.centerX) + Math.abs(room.centerY - startRoom.centerY);
        const bestDist = Math.abs(best.centerX - startRoom.centerX) + Math.abs(best.centerY - startRoom.centerY);
        return dist > bestDist ? room : best;
    });
    ELEVATOR.x = exitRoom.centerX;
    ELEVATOR.y = exitRoom.centerY;
    MAP[exitRoom.centerY][exitRoom.centerX] = 4;

    // Add doors at valid doorway positions (walls on one axis, open on the other)
    const numDoors = 2 + Math.floor(Math.random() * 2); // 2-3 doors for 24x24 map
    const doorCandidates = allTiles.filter(tile => {
        const { x, y } = tile;

        // Must be an open tile, not too close to start/exit
        if (MAP[y][x] !== 0) return false;
        const distFromStart = Math.abs(x - startRoom.centerX) + Math.abs(y - startRoom.centerY);
        const distFromExit = Math.abs(x - exitRoom.centerX) + Math.abs(y - exitRoom.centerY);
        if (distFromStart <= 5 || distFromExit <= 5) return false;

        // Check bounds
        if (x <= 1 || x >= MAP_W - 2 || y <= 1 || y >= MAP_H - 2) return false;

        // Get neighboring tiles
        const above = MAP[y - 1][x];
        const below = MAP[y + 1][x];
        const left = MAP[y][x - 1];
        const right = MAP[y][x + 1];

        // Valid horizontal doorway: walls above and below, open left and right
        const horizontalDoor = (above === 1 && below === 1 && left === 0 && right === 0);

        // Valid vertical doorway: walls left and right, open above and below
        const verticalDoor = (left === 1 && right === 1 && above === 0 && below === 0);

        return horizontalDoor || verticalDoor;
    });

    for (let i = 0; i < numDoors && doorCandidates.length > 0; i++) {
        const idx = Math.floor(Math.random() * doorCandidates.length);
        const tile = doorCandidates.splice(idx, 1)[0];
        MAP[tile.y][tile.x] = 2;
        doors.push({ x: tile.x, y: tile.y, state: 0, opening: false, type: 'normal' });
    }

    // KEY AND LOCKED DOOR DISABLED FOR NOW - code kept for future use
    // TODO: Fix map generation to ensure key is always accessible before re-enabling
    /*
    // Place locked door near the exit room (blocks access to exit area)
    const lockedDoorCandidates = [];
    for (let y = 1; y < MAP_H - 1; y++) {
        for (let x = 1; x < MAP_W - 1; x++) {
            if (MAP[y][x] !== 0) continue;

            // Must be close to exit room but not inside it
            const distFromExit = Math.abs(x - exitRoom.centerX) + Math.abs(y - exitRoom.centerY);
            if (distFromExit < 3 || distFromExit > 8) continue;

            // Check for valid doorway position
            const above = MAP[y - 1][x];
            const below = MAP[y + 1][x];
            const left = MAP[y][x - 1];
            const right = MAP[y][x + 1];

            const horizontalDoor = (above === 1 && below === 1 && left === 0 && right === 0);
            const verticalDoor = (left === 1 && right === 1 && above === 0 && below === 0);

            if (horizontalDoor || verticalDoor) {
                lockedDoorCandidates.push({ x, y, distFromExit });
            }
        }
    }

    // Sort by distance to exit (prefer closer ones)
    lockedDoorCandidates.sort((a, b) => a.distFromExit - b.distFromExit);

    if (lockedDoorCandidates.length > 0) {
        // Pick one of the closest candidates
        const pickIdx = Math.floor(Math.random() * Math.min(3, lockedDoorCandidates.length));
        const lockedTile = lockedDoorCandidates[pickIdx];
        MAP[lockedTile.y][lockedTile.x] = 3; // Locked door tile type
        doors.push({ x: lockedTile.x, y: lockedTile.y, state: 0, opening: false, type: 'locked' });
    }

    // Place key in a room far from exit but not the start room
    const keyRoomCandidates = rooms.filter(room => {
        if (room === startRoom || room === exitRoom) return false;
        const distFromExit = Math.abs(room.centerX - exitRoom.centerX) + Math.abs(room.centerY - exitRoom.centerY);
        const distFromStart = Math.abs(room.centerX - startRoom.centerX) + Math.abs(room.centerY - startRoom.centerY);
        // Key should be far from exit, moderately far from start (adjusted for 24x24 map)
        return distFromExit > 6 && distFromStart > 3;
    });

    // Fall back to any non-start/exit room if no good candidates
    const keyRoom = keyRoomCandidates.length > 0
        ? keyRoomCandidates[Math.floor(Math.random() * keyRoomCandidates.length)]
        : rooms.find(r => r !== startRoom && r !== exitRoom);

    if (keyRoom) {
        levelKey = {
            x: keyRoom.centerX + 0.5,
            y: keyRoom.centerY + 0.5,
            collected: false
        };
    }
    */
    // Mark key as collected so locked doors (if any) can be opened
    levelKey = { x: 0, y: 0, collected: true };
    hasKey = true;

    // Helper to check if position is in player's initial field of view
    function isInPlayerInitialView(x, y) {
        const dx = x - playerStart.x;
        const dy = y - playerStart.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // Player starts facing angle 0 (east)
        const angleToEnemy = Math.atan2(dy, dx);
        let angleDiff = angleToEnemy - 0; // Player starts at angle 0

        // Normalize to -PI to PI
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

        // Check if within FOV and close enough to be visible
        const inFOV = Math.abs(angleDiff) < FOV / 2 + 0.1;
        const closeEnough = dist < 8; // Only check nearby enemies

        if (!inFOV || !closeEnough) return false;

        // Check if there's a wall blocking line of sight
        const steps = Math.ceil(dist * 2);
        for (let i = 1; i < steps; i++) {
            const t = i / steps;
            const checkX = Math.floor(playerStart.x + dx * t);
            const checkY = Math.floor(playerStart.y + dy * t);
            if (MAP[checkY] && MAP[checkY][checkX] === 1) {
                return false; // Wall blocks view
            }
        }

        return true; // Enemy would be visible
    }

    // Generate enemies in rooms
    enemies = [];
    const numEnemies = 4 + Math.floor(Math.random() * 4) + currentLevel; // Scaled for 24x24 map

    for (const room of rooms) {
        // Skip start and exit rooms
        if (room === startRoom || room === exitRoom) continue;

        const enemiesInRoom = Math.min(room.enemySpots, Math.ceil(numEnemies / rooms.length));
        for (let i = 0; i < enemiesInRoom; i++) {
            // Try multiple positions to avoid spawning in player's view
            let placed = false;
            for (let attempt = 0; attempt < 10 && !placed; attempt++) {
                const ex = room.x + 1 + Math.floor(Math.random() * (room.width - 2));
                const ey = room.y + 1 + Math.floor(Math.random() * (room.height - 2));

                if (MAP[ey][ex] === 0 && !isInPlayerInitialView(ex + 0.5, ey + 0.5)) {
                    enemies.push({
                        x: ex + 0.5,
                        y: ey + 0.5,
                        health: 30 * currentLevel,
                        speed: 0.02,
                        alive: true,
                        dying: false,
                        deathTimer: 0,
                        seen: false,
                        damageFlash: 0
                    });
                    placed = true;
                }
            }
        }
    }
}

// Game state: 'playing', 'gameover', 'victory'
let gameState = 'playing';
let currentLevel = 1;

// Frame rate limiting
const TARGET_FPS = 120;
const FRAME_TIME = 1000 / TARGET_FPS;
let lastFrameTime = 0;

generateMap();

// Player - start position set by map generator
let player = { x: playerStart.x, y: playerStart.y, angle: 0, speed: 0.06, rotSpeed: 0.04, health: 100, ammo: 50, kills: 0 };

// Restart the game with a fresh map (full reset)
function restartGame() {
    currentLevel = 1;
    player.health = 100;
    player.ammo = 50;
    player.kills = 0;
    nextLevel(true);
}

// Advance to next level (keeps health/ammo if not a full reset)
function nextLevel(fullReset = false) {
    // Clear arrays
    MAP.length = 0;
    doors.length = 0;
    enemies.length = 0;
    lights.length = 0;
    ammoBoxes.length = 0;
    healthPacks.length = 0;
    plasmaBalls.length = 0;

    // Reset victory state (music keeps playing independently)
    victoryPlayed = false;

    // Generate new color theme for this level
    generateLevelTheme();
    updateCrosshairColor();

    // Regenerate map, enemies, lights, ammo, health
    generateMap();
    generateLights();
    generateAmmoBoxes();
    generateHealthPacks();

    // Reset player position (keep health/ammo unless full reset)
    player.x = playerStart.x;
    player.y = playerStart.y;
    player.angle = 0;
    rawMouseAngle = 0;

    // Reset other state
    shootCooldown = 0;
    muzzleFlash = 0;
    damageFlash = 0;
    plasmaballCooldown = 0;
    headLookDir = 0;
    headLookTimer = 0;
    lastPlayerAngle = 0;
    headDamageFlash = 0;
    currentWeapon = 1;
    swingAnimation = 0;

    // Clear key states to prevent immediate actions
    for (const key in keys) {
        keys[key] = false;
    }

    // Reset game state
    gameState = 'playing';
}

// Light sprites - placed in room corners and randomly in hallways
const lights = [];
function generateLights() {
    // First, place lights in corners of large rooms
    for (const room of roomCenters) {
        if (room.template === 'large') {
            // Place lights near corners of large rooms (5x5, so Â±2 from center)
            const corners = [
                { x: room.x - 2, y: room.y - 2 },
                { x: room.x + 2, y: room.y - 2 },
                { x: room.x - 2, y: room.y + 2 },
                { x: room.x + 2, y: room.y + 2 }
            ];
            for (const corner of corners) {
                if (corner.x > 0 && corner.x < MAP_W - 1 && corner.y > 0 && corner.y < MAP_H - 1) {
                    if (MAP[Math.floor(corner.y)][Math.floor(corner.x)] === 0) {
                        lights.push({
                            x: corner.x + 0.5,
                            y: corner.y + 0.5,
                            color: '#0cf',
                            phase: Math.random() * Math.PI * 2
                        });
                    }
                }
            }
        }
    }

    // Then add some random lights in hallways and other rooms
    const numLights = 2 + Math.floor(Math.random() * 3); // 2-4 additional lights for 24x24 map
    const walkable = [];
    for (let y = 0; y < MAP_H; y++) {
        for (let x = 0; x < MAP_W; x++) {
            if (MAP[y][x] === 0) {
                // Avoid placing too close to existing lights
                const tooClose = lights.some(l => {
                    const dx = l.x - (x + 0.5);
                    const dy = l.y - (y + 0.5);
                    return Math.sqrt(dx * dx + dy * dy) < 4;
                });
                if (!tooClose) {
                    walkable.push({ x: x + 0.5, y: y + 0.5 });
                }
            }
        }
    }

    for (let i = 0; i < numLights && walkable.length > 0; i++) {
        const idx = Math.floor(Math.random() * walkable.length);
        const pos = walkable.splice(idx, 1)[0];
        const offsetX = (Math.random() - 0.5) * 0.6;
        const offsetY = (Math.random() - 0.5) * 0.6;
        lights.push({
            x: pos.x + offsetX,
            y: pos.y + offsetY,
            color: '#0cf',
            phase: Math.random() * Math.PI * 2
        });
    }
}
generateLights();

// Ammo boxes - randomly generated along hallways
const ammoBoxes = [];
function generateAmmoBoxes() {
    const numBoxes = 2 + Math.floor(Math.random() * 2); // 2-3 ammo boxes for 24x24 map
    const walkable = [];
    for (let y = 0; y < MAP_H; y++) {
        for (let x = 0; x < MAP_W; x++) {
            if (MAP[y][x] === 0) {
                walkable.push({ x: x + 0.5, y: y + 0.5 });
            }
        }
    }
    for (let i = 0; i < numBoxes && walkable.length > 0; i++) {
        const idx = Math.floor(Math.random() * walkable.length);
        const pos = walkable.splice(idx, 1)[0];
        ammoBoxes.push({
            x: pos.x,
            y: pos.y,
            collected: false
        });
    }
}
generateAmmoBoxes();

// Health packs - randomly generated along hallways
const healthPacks = [];
function generateHealthPacks() {
    const numPacks = 1 + Math.floor(Math.random() * 2); // 1-2 health packs for 24x24 map
    const walkable = [];
    for (let y = 0; y < MAP_H; y++) {
        for (let x = 0; x < MAP_W; x++) {
            if (MAP[y][x] === 0) {
                walkable.push({ x: x + 0.5, y: y + 0.5 });
            }
        }
    }
    for (let i = 0; i < numPacks && walkable.length > 0; i++) {
        const idx = Math.floor(Math.random() * walkable.length);
        const pos = walkable.splice(idx, 1)[0];
        healthPacks.push({
            x: pos.x,
            y: pos.y,
            collected: false
        });
    }
}
generateHealthPacks();

// Shooting state
let shootCooldown = 0;
let muzzleFlash = 0;
let damageFlash = 0;

// Plasma ball projectiles
const plasmaBalls = [];
let plasmaballCooldown = 0;

// HUD space-man head state
let headLookDir = 0; // -1 left, 0 center, 1 right
let headLookTimer = 0;
let lastPlayerAngle = 0;
let headDamageFlash = 0;

// Weapon system: 0 = hammer (melee), 1 = gun (ranged)
let currentWeapon = 1;
let swingAnimation = 0; // For hammer swing

// === MUSIC SYSTEM ===
let audioCtx = null;
let musicStarted = false;
let musicPlaying = false;
let victoryPlayed = false;

function startMusic() {
    if (musicStarted) return;
    musicStarted = true;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    const BPM = 140;
    const beatTime = 60 / BPM;
    const barTime = beatTime * 4;

    // Master volume
    const masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.4;
    masterGain.connect(audioCtx.destination);

    // Kick drum
    function playKick(time) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = 'sine';
        osc.frequency.setValueAtTime(150, time);
        osc.frequency.exponentialRampToValueAtTime(30, time + 0.1);

        gain.gain.setValueAtTime(1, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(time);
        osc.stop(time + 0.3);
    }

    // Hi-hat
    function playHiHat(time, accent = false) {
        const bufferSize = audioCtx.sampleRate * 0.05;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;

        const filter = audioCtx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 8000;

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(accent ? 0.15 : 0.08, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);

        noise.start(time);
        noise.stop(time + 0.05);
    }

    // Bass synth
    function playBass(time, freq, duration = 0.2) {
        const osc = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        osc2.type = 'square';
        osc2.frequency.value = freq * 0.5;

        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(800, time);
        filter.frequency.exponentialRampToValueAtTime(200, time + duration);

        gain.gain.setValueAtTime(0.3, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + duration);

        osc.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);

        osc.start(time);
        osc2.start(time);
        osc.stop(time + duration);
        osc2.stop(time + duration);
    }

    // Synth pad (atmospheric)
    function playPad(time, freq, duration = 2) {
        const osc = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        osc2.type = 'sawtooth';
        osc2.frequency.value = freq * 1.005; // Slight detune for richness

        filter.type = 'lowpass';
        filter.frequency.value = 1500;
        filter.Q.value = 2;

        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.08, time + 0.3);
        gain.gain.linearRampToValueAtTime(0.08, time + duration - 0.3);
        gain.gain.linearRampToValueAtTime(0, time + duration);

        osc.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);

        osc.start(time);
        osc2.start(time);
        osc.stop(time + duration);
        osc2.stop(time + duration);
    }

    // Arpeggio synth
    function playArp(time, freq) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc.type = 'square';
        osc.frequency.value = freq;

        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(3000, time);
        filter.frequency.exponentialRampToValueAtTime(500, time + 0.15);

        gain.gain.setValueAtTime(0.1, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);

        osc.start(time);
        osc.stop(time + 0.15);
    }

    // Schedule music loop
    function scheduleBar(barStartTime, barNum) {
        // Kick on 1, 2, 3, 4 (four-on-floor)
        for (let beat = 0; beat < 4; beat++) {
            playKick(barStartTime + beat * beatTime);
        }

        // Hi-hats on eighth notes
        for (let i = 0; i < 8; i++) {
            playHiHat(barStartTime + i * beatTime * 0.5, i % 2 === 0);
        }

        // Bass line (minor key pattern)
        const bassNotes = [55, 55, 65.41, 73.42]; // A1, A1, C2, D2
        const bassPattern = barNum % 2 === 0 ? [0, 0, 1, 2] : [0, 3, 1, 0];
        for (let i = 0; i < 4; i++) {
            playBass(barStartTime + i * beatTime, bassNotes[bassPattern[i]], beatTime * 0.8);
        }

        // Pad chord every 2 bars
        if (barNum % 2 === 0) {
            const padFreqs = barNum % 4 === 0 ? [220, 261.63, 329.63] : [196, 246.94, 293.66]; // Am, G
            padFreqs.forEach(f => playPad(barStartTime, f, barTime * 2));
        }

        // Arpeggio pattern
        const arpNotes = [440, 523.25, 659.25, 523.25, 440, 392, 440, 523.25]; // A4, C5, E5...
        for (let i = 0; i < 8; i++) {
            if ((barNum + i) % 3 !== 0) { // Add some variation
                playArp(barStartTime + i * beatTime * 0.5, arpNotes[i]);
            }
        }
    }

    // Main music scheduler
    let nextBarTime = audioCtx.currentTime + 0.1;
    let barNumber = 0;

    function scheduler() {
        if (!musicPlaying) return; // Stop scheduling when music stops
        while (nextBarTime < audioCtx.currentTime + 0.5) {
            scheduleBar(nextBarTime, barNumber);
            nextBarTime += barTime;
            barNumber++;
        }
        setTimeout(scheduler, 100);
    }

    musicPlaying = true;
    scheduler();
}

function stopMusic() {
    musicPlaying = false;
}

// === SOUND EFFECTS ===
function ensureAudioCtx() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    return audioCtx;
}

function playGunSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Plasma zap sound
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(800, now);
    osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);

    gain.gain.setValueAtTime(0.15, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.1);

    // Add a click/snap
    const osc2 = ctx.createOscillator();
    const gain2 = ctx.createGain();
    osc2.type = 'square';
    osc2.frequency.value = 150;
    gain2.gain.setValueAtTime(0.1, now);
    gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
    osc2.connect(gain2);
    gain2.connect(ctx.destination);
    osc2.start(now);
    osc2.stop(now + 0.03);
}

function playHammerSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Whoosh sound (noise burst)
    const bufferSize = ctx.sampleRate * 0.15;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
    }

    const noise = ctx.createBufferSource();
    noise.buffer = buffer;

    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 400;
    filter.Q.value = 1;

    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.12, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

    noise.connect(filter);
    filter.connect(gain);
    gain.connect(ctx.destination);

    noise.start(now);
    noise.stop(now + 0.15);

    // Electric zap
    const osc = ctx.createOscillator();
    const oscGain = ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(200, now + 0.05);
    osc.frequency.exponentialRampToValueAtTime(80, now + 0.12);
    oscGain.gain.setValueAtTime(0.08, now + 0.05);
    oscGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
    osc.connect(oscGain);
    oscGain.connect(ctx.destination);
    osc.start(now + 0.05);
    osc.stop(now + 0.12);
}

function playEnemyHitSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Soft thud
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(100, now);
    osc.frequency.exponentialRampToValueAtTime(50, now + 0.08);

    gain.gain.setValueAtTime(0.12, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.08);
}

function playEnemyRoarSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Scary descending growl
    const osc = ctx.createOscillator();
    const osc2 = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(180, now);
    osc.frequency.exponentialRampToValueAtTime(60, now + 0.4);

    osc2.type = 'square';
    osc2.frequency.setValueAtTime(185, now);
    osc2.frequency.exponentialRampToValueAtTime(55, now + 0.4);

    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(600, now);
    filter.frequency.exponentialRampToValueAtTime(200, now + 0.4);

    gain.gain.setValueAtTime(0.15, now);
    gain.gain.linearRampToValueAtTime(0.2, now + 0.1);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

    osc.connect(filter);
    osc2.connect(filter);
    filter.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc2.start(now);
    osc.stop(now + 0.4);
    osc2.stop(now + 0.4);

    // Add a harsh noise burst
    const bufferSize = ctx.sampleRate * 0.15;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
    }

    const noise = ctx.createBufferSource();
    noise.buffer = buffer;

    const noiseFilter = ctx.createBiquadFilter();
    noiseFilter.type = 'bandpass';
    noiseFilter.frequency.value = 300;
    noiseFilter.Q.value = 2;

    const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(0.08, now);
    noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

    noise.connect(noiseFilter);
    noiseFilter.connect(noiseGain);
    noiseGain.connect(ctx.destination);

    noise.start(now);
    noise.stop(now + 0.15);
}

function playDoorOpenSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Hydraulic hiss
    const bufferSize = ctx.sampleRate * 0.4;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        const env = Math.exp(-i / (bufferSize * 0.3));
        data[i] = (Math.random() * 2 - 1) * env;
    }

    const noise = ctx.createBufferSource();
    noise.buffer = buffer;

    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.setValueAtTime(2000, now);
    filter.frequency.exponentialRampToValueAtTime(500, now + 0.3);
    filter.Q.value = 2;

    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.12, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

    noise.connect(filter);
    filter.connect(gain);
    gain.connect(ctx.destination);

    noise.start(now);
    noise.stop(now + 0.4);

    // Mechanical clunk
    const osc = ctx.createOscillator();
    const oscGain = ctx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(80, now);
    osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
    oscGain.gain.setValueAtTime(0.1, now);
    oscGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
    osc.connect(oscGain);
    oscGain.connect(ctx.destination);
    osc.start(now);
    osc.stop(now + 0.1);
}

function playLockedDoorSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Denied buzz
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(80, now);

    gain.gain.setValueAtTime(0.15, now);
    gain.gain.setValueAtTime(0, now + 0.08);
    gain.gain.setValueAtTime(0.15, now + 0.12);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.25);

    // Low clunk (door won't budge)
    const osc2 = ctx.createOscillator();
    const gain2 = ctx.createGain();
    osc2.type = 'sine';
    osc2.frequency.setValueAtTime(60, now);
    osc2.frequency.exponentialRampToValueAtTime(30, now + 0.1);
    gain2.gain.setValueAtTime(0.12, now);
    gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
    osc2.connect(gain2);
    gain2.connect(ctx.destination);
    osc2.start(now);
    osc2.stop(now + 0.1);
}

function playKeyPickupSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Triumphant ascending chime
    const notes = [523.25, 659.25, 783.99]; // C5, E5, G5

    notes.forEach((freq, i) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();

        osc.type = 'sine';
        osc.frequency.value = freq;

        const startTime = now + i * 0.08;
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.15, startTime + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.3);

        osc.connect(gain);
        gain.connect(ctx.destination);

        osc.start(startTime);
        osc.stop(startTime + 0.3);
    });

    // Add a metallic shimmer
    const bufferSize = ctx.sampleRate * 0.2;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.3)) * 0.3;
    }

    const noise = ctx.createBufferSource();
    noise.buffer = buffer;

    const filter = ctx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 4000;

    const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(0.08, now);
    noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

    noise.connect(filter);
    filter.connect(noiseGain);
    noiseGain.connect(ctx.destination);

    noise.start(now);
    noise.stop(now + 0.2);
}

function playAmmoPickupSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Quick ascending blip
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(400, now);
    osc.frequency.exponentialRampToValueAtTime(800, now + 0.08);

    gain.gain.setValueAtTime(0.1, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.1);

    // Second higher blip
    const osc2 = ctx.createOscillator();
    const gain2 = ctx.createGain();

    osc2.type = 'square';
    osc2.frequency.setValueAtTime(600, now + 0.05);
    osc2.frequency.exponentialRampToValueAtTime(1200, now + 0.12);

    gain2.gain.setValueAtTime(0.08, now + 0.05);
    gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

    osc2.connect(gain2);
    gain2.connect(ctx.destination);

    osc2.start(now + 0.05);
    osc2.stop(now + 0.15);
}

function playPlayerHitSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // 8-bit "oof" sound - short low grunt
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(150, now);
    osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);

    gain.gain.setValueAtTime(0.15, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.12);

    // Add some noise for texture
    const bufferSize = ctx.sampleRate * 0.08;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize) * 0.5;
    }

    const noise = ctx.createBufferSource();
    noise.buffer = buffer;

    const noiseFilter = ctx.createBiquadFilter();
    noiseFilter.type = 'lowpass';
    noiseFilter.frequency.value = 400;

    const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(0.08, now);
    noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

    noise.connect(noiseFilter);
    noiseFilter.connect(noiseGain);
    noiseGain.connect(ctx.destination);

    noise.start(now);
    noise.stop(now + 0.08);
}

function playEmptyClickSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Short dry click
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(120, now);
    osc.frequency.exponentialRampToValueAtTime(60, now + 0.05);

    gain.gain.setValueAtTime(0.25, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.05);
}

function playPlasmaBallSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Mid thump
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(150, now);
    osc.frequency.exponentialRampToValueAtTime(80, now + 0.2);

    gain.gain.setValueAtTime(0.2, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.25);

    // Mid rumble
    const osc2 = ctx.createOscillator();
    const gain2 = ctx.createGain();

    osc2.type = 'sawtooth';
    osc2.frequency.setValueAtTime(120, now);
    osc2.frequency.exponentialRampToValueAtTime(60, now + 0.25);

    gain2.gain.setValueAtTime(0.1, now);
    gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.25);

    osc2.connect(gain2);
    gain2.connect(ctx.destination);

    osc2.start(now);
    osc2.stop(now + 0.25);
}

function playHealthPickupSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Warm healing tone
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(440, now);
    osc.frequency.exponentialRampToValueAtTime(880, now + 0.15);

    gain.gain.setValueAtTime(0.12, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.2);

    // Harmony note
    const osc2 = ctx.createOscillator();
    const gain2 = ctx.createGain();

    osc2.type = 'sine';
    osc2.frequency.setValueAtTime(554, now + 0.05);
    osc2.frequency.exponentialRampToValueAtTime(1108, now + 0.18);

    gain2.gain.setValueAtTime(0.08, now + 0.05);
    gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.22);

    osc2.connect(gain2);
    gain2.connect(ctx.destination);

    osc2.start(now + 0.05);
    osc2.stop(now + 0.22);
}

function playEnemyDeathSound() {
    const ctx = ensureAudioCtx();
    const now = ctx.currentTime;

    // Descending tone (alien death cry)
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(300, now);
    osc.frequency.exponentialRampToValueAtTime(60, now + 0.3);

    gain.gain.setValueAtTime(0.1, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.3);

    // Static burst
    const bufferSize = ctx.sampleRate * 0.2;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize) * 0.5;
    }

    const noise = ctx.createBufferSource();
    noise.buffer = buffer;

    const filter = ctx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 2000;

    const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(0.06, now);
    noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

    noise.connect(filter);
    filter.connect(noiseGain);
    noiseGain.connect(ctx.destination);

    noise.start(now);
    noise.stop(now + 0.2);
}

function playVictoryMusic() {
    if (victoryPlayed) return;
    victoryPlayed = true;
    // Don't stop the background music - just play victory chime on top

    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    const masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.4;
    masterGain.connect(audioCtx.destination);

    // Soft victory chime
    function playChime(time, freq, duration = 0.4) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = 'sine';
        osc.frequency.value = freq;

        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.12, time + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.01, time + duration);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(time);
        osc.stop(time + duration);
    }

    const now = audioCtx.currentTime;

    // Simple ascending chime (C-E-G)
    playChime(now, 523.25, 0.5);        // C5
    playChime(now + 0.15, 659.25, 0.5); // E5
    playChime(now + 0.3, 783.99, 0.8);  // G5 (held slightly longer)
}

// Input - use e.code for reliable key detection
const keys = {};
let rawMouseAngle = 0; // Accumulate raw mouse movement at full resolution
const MOUSE_SENSITIVITY = 0.002;

// Firefox detection and mouse smoothing (Firefox doesn't support unadjustedMovement)
const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');
const SMOOTHING_SAMPLES = 3; // Number of samples for moving average
const IMMEDIATE_SAMPLES = 2; // First N samples are applied immediately
const MOVEMENT_TIMEOUT = 80; // ms - reset to "initial" state after this pause
const mouseMovementHistory = []; // Recent movement values for smoothing
let lastMovementTime = 0;

function getSmoothedMovement(rawMovement) {
    if (!isFirefox) {
        return rawMovement; // No smoothing needed for browsers with raw input
    }

    const now = performance.now();

    // Reset history if there's been a pause in movement
    if (now - lastMovementTime > MOVEMENT_TIMEOUT) {
        mouseMovementHistory.length = 0;
    }
    lastMovementTime = now;

    // Add to history
    mouseMovementHistory.push(rawMovement);

    // Keep only recent samples
    while (mouseMovementHistory.length > SMOOTHING_SAMPLES) {
        mouseMovementHistory.shift();
    }

    // First few movements are immediate (responsive start)
    if (mouseMovementHistory.length <= IMMEDIATE_SAMPLES) {
        return rawMovement;
    }

    // After initial movements, return smoothed average
    const sum = mouseMovementHistory.reduce((a, b) => a + b, 0);
    return sum / mouseMovementHistory.length;
}

window.addEventListener('keydown', e => {
    keys[e.code] = true;
    e.preventDefault();
});
window.addEventListener('keyup', e => {
    keys[e.code] = false;
});

canvas.addEventListener('click', () => {
    // Handle end screens
    if (gameState === 'gameover') {
        restartGame();
        return;
    }
    if (gameState === 'victory') {
        currentLevel++;
        nextLevel();
        return;
    }
    startMusic(); // Start music on first click
    if (document.pointerLockElement !== canvas) {
        // Request pointer lock with unadjusted movement for raw mouse input (if supported)
        canvas.requestPointerLock({ unadjustedMovement: true }).catch(() => {
            // Fall back to standard pointer lock if unadjusted not supported
            canvas.requestPointerLock();
        });
    }
});
document.addEventListener('mousemove', e => {
    if (document.pointerLockElement === canvas) {
        // Accumulate mouse movement (smoothed on Firefox, raw on other browsers)
        const movement = getSmoothedMovement(e.movementX);
        rawMouseAngle += movement;
        player.angle = rawMouseAngle * MOUSE_SENSITIVITY;
    }
});
document.addEventListener('mousedown', e => {
    if (document.pointerLockElement === canvas) {
        if (e.button === 0) {
            attack();
        } else if (e.button === 2) {
            firePlasmaBall();
        }
    }
});

// Prevent context menu on right click
document.addEventListener('contextmenu', e => {
    e.preventDefault();
});

// === TOUCH CONTROLS ===
const touchState = {
    move: { active: false, id: null, startX: 0, startY: 0, dx: 0, dy: 0, startTime: 0, moved: false },
    look: { active: false, id: null, startX: 0, startY: 0, dx: 0, dy: 0, startTime: 0, moved: false }
};

// Left joystick for movement
const joystickMove = document.getElementById('joystick-move');
const moveKnob = document.getElementById('move-knob');

joystickMove.addEventListener('touchstart', e => {
    e.preventDefault();
    startMusic();
    const touch = e.changedTouches[0];
    const rect = joystickMove.getBoundingClientRect();
    touchState.move.active = true;
    touchState.move.id = touch.identifier;
    touchState.move.startX = rect.left + rect.width / 2;
    touchState.move.startY = rect.top + rect.height / 2;
    touchState.move.startTime = Date.now();
    touchState.move.moved = false;
    updateMoveJoystick(touch.clientX, touch.clientY);
});

joystickMove.addEventListener('touchmove', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
        if (touch.identifier === touchState.move.id) {
            const dx = touch.clientX - touchState.move.startX;
            const dy = touch.clientY - touchState.move.startY;
            if (Math.sqrt(dx * dx + dy * dy) > MOVE_THRESHOLD) {
                touchState.move.moved = true;
            }
            updateMoveJoystick(touch.clientX, touch.clientY);
        }
    }
});

joystickMove.addEventListener('touchend', e => {
    for (const touch of e.changedTouches) {
        if (touch.identifier === touchState.move.id) {
            // Check for tap (short duration, minimal movement) to open doors
            const tapDuration = Date.now() - touchState.move.startTime;
            if (tapDuration < TAP_THRESHOLD && !touchState.move.moved) {
                // Handle game state or open door
                if (gameState === 'gameover') {
                    restartGame();
                } else if (gameState === 'victory') {
                    currentLevel++;
                    nextLevel();
                } else {
                    tryOpenDoor();
                }
            }
            touchState.move.active = false;
            touchState.move.dx = 0;
            touchState.move.dy = 0;
            moveKnob.style.transform = 'translate(-50%, -50%)';
        }
    }
});

joystickMove.addEventListener('touchcancel', e => {
    touchState.move.active = false;
    touchState.move.dx = 0;
    touchState.move.dy = 0;
    moveKnob.style.transform = 'translate(-50%, -50%)';
});

function updateMoveJoystick(x, y) {
    const maxDist = 50;
    let dx = x - touchState.move.startX;
    let dy = y - touchState.move.startY;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist > maxDist) {
        dx = (dx / dist) * maxDist;
        dy = (dy / dist) * maxDist;
    }

    touchState.move.dx = dx / maxDist;
    touchState.move.dy = dy / maxDist;

    moveKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
}

// Right joystick for looking + tap to attack
const joystickLook = document.getElementById('joystick-look');
const lookKnob = document.getElementById('look-knob');
const TAP_THRESHOLD = 200; // ms
const MOVE_THRESHOLD = 10; // pixels

joystickLook.addEventListener('touchstart', e => {
    e.preventDefault();
    startMusic();
    const touch = e.changedTouches[0];
    const rect = joystickLook.getBoundingClientRect();
    touchState.look.active = true;
    touchState.look.id = touch.identifier;
    touchState.look.startX = rect.left + rect.width / 2;
    touchState.look.startY = rect.top + rect.height / 2;
    touchState.look.startTime = Date.now();
    touchState.look.moved = false;
    updateLookJoystick(touch.clientX, touch.clientY);
});

joystickLook.addEventListener('touchmove', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
        if (touch.identifier === touchState.look.id) {
            const dx = touch.clientX - touchState.look.startX;
            const dy = touch.clientY - touchState.look.startY;
            if (Math.sqrt(dx * dx + dy * dy) > MOVE_THRESHOLD) {
                touchState.look.moved = true;
            }
            updateLookJoystick(touch.clientX, touch.clientY);
        }
    }
});

joystickLook.addEventListener('touchend', e => {
    for (const touch of e.changedTouches) {
        if (touch.identifier === touchState.look.id) {
            // Check for tap (short duration, minimal movement)
            const tapDuration = Date.now() - touchState.look.startTime;
            if (tapDuration < TAP_THRESHOLD && !touchState.look.moved) {
                // Handle game state or attack
                if (gameState === 'gameover') {
                    restartGame();
                } else if (gameState === 'victory') {
                    currentLevel++;
                    nextLevel();
                } else {
                    attack();
                }
            }
            touchState.look.active = false;
            touchState.look.dx = 0;
            touchState.look.dy = 0;
            lookKnob.style.transform = 'translate(-50%, -50%)';
        }
    }
});

joystickLook.addEventListener('touchcancel', e => {
    touchState.look.active = false;
    touchState.look.dx = 0;
    touchState.look.dy = 0;
    lookKnob.style.transform = 'translate(-50%, -50%)';
});

function updateLookJoystick(x, y) {
    const maxDist = 50;
    let dx = x - touchState.look.startX;
    let dy = y - touchState.look.startY;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist > maxDist) {
        dx = (dx / dist) * maxDist;
        dy = (dy / dist) * maxDist;
    }

    touchState.look.dx = dx / maxDist;
    touchState.look.dy = dy / maxDist;

    // Note: Look rotation is now applied continuously in handleInput()

    lookKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
}

// Weapon switch button
const btnWeapon = document.getElementById('btn-weapon');
btnWeapon.addEventListener('touchstart', e => {
    e.preventDefault();
    startMusic();
    // Toggle between weapons
    currentWeapon = currentWeapon === 0 ? 1 : 0;
});

// Weapon switching and restart
window.addEventListener('keydown', e => {
    if (e.code === 'Digit1') currentWeapon = 0; // Hammer
    if (e.code === 'Digit2') currentWeapon = 1; // Gun

    // Handle end screens
    if (e.code === 'Space' && gameState === 'gameover') {
        restartGame();
    }
    if (e.code === 'Space' && gameState === 'victory') {
        currentLevel++;
        nextLevel();
    }
});

// Get door at position
function getDoor(x, y) {
    return doors.find(d => d.x === x && d.y === y);
}

// Check if position is blocked (wall or closed door)
function isWall(x, y) {
    const mapX = Math.floor(x);
    const mapY = Math.floor(y);
    if (mapX < 0 || mapX >= MAP_W || mapY < 0 || mapY >= MAP_H) return true;
    const tile = MAP[mapY][mapX];
    if (tile === 1) return true;
    if (tile === 2 || tile === 3) { // Normal door or locked door
        const door = getDoor(mapX, mapY);
        return door && door.state < 0.8; // Door blocks if less than 80% open
    }
    // Tile 4 (elevator interior) is walkable
    return false;
}

// Check if player is in the elevator
function isInElevator() {
    const px = Math.floor(player.x);
    const py = Math.floor(player.y);
    return px === ELEVATOR.x && py === ELEVATOR.y;
}

// Try to open nearby door
function tryOpenDoor() {
    const checkDist = 1.5;
    const px = player.x + Math.cos(player.angle) * checkDist;
    const py = player.y + Math.sin(player.angle) * checkDist;

    for (const door of doors) {
        const dx = (door.x + 0.5) - player.x;
        const dy = (door.y + 0.5) - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 2 && door.state < 0.5 && !door.opening) {
            // Check if door is locked
            if (door.type === 'locked' && !hasKey) {
                playLockedDoorSound();
                return;
            }
            door.opening = true;
            playDoorOpenSound();
        }
    }
}

// Update doors (animate opening)
function updateDoors() {
    for (const door of doors) {
        if (door.opening && door.state < 1) {
            door.state += 0.05; // Opening speed
            if (door.state >= 1) {
                door.state = 1;
                door.opening = false;
            }
        }
    }
}

// Cast a single ray and return distance + wall hit position
function castRay(angle) {
    const sin = Math.sin(angle);
    const cos = Math.cos(angle);

    // DDA algorithm
    let mapX = Math.floor(player.x);
    let mapY = Math.floor(player.y);

    const deltaDistX = Math.abs(1 / cos) || 1e10;
    const deltaDistY = Math.abs(1 / sin) || 1e10;

    let stepX, stepY, sideDistX, sideDistY;

    if (cos < 0) {
        stepX = -1;
        sideDistX = (player.x - mapX) * deltaDistX;
    } else {
        stepX = 1;
        sideDistX = (mapX + 1 - player.x) * deltaDistX;
    }
    if (sin < 0) {
        stepY = -1;
        sideDistY = (player.y - mapY) * deltaDistY;
    } else {
        stepY = 1;
        sideDistY = (mapY + 1 - player.y) * deltaDistY;
    }

    let side = 0;
    let dist = 0;

    for (let i = 0; i < MAX_DEPTH * MAP_W; i++) {
        if (sideDistX < sideDistY) {
            sideDistX += deltaDistX;
            mapX += stepX;
            side = 0;
        } else {
            sideDistY += deltaDistY;
            mapY += stepY;
            side = 1;
        }

        if (mapX < 0 || mapX >= MAP_W || mapY < 0 || mapY >= MAP_H) break;

        const tile = MAP[mapY][mapX];
        if (tile === 1) {
            if (side === 0) dist = sideDistX - deltaDistX;
            else dist = sideDistY - deltaDistY;
            // Calculate wall hit position (0-1 along the wall)
            let wallX;
            if (side === 0) wallX = player.y + dist * sin;
            else wallX = player.x + dist * cos;
            wallX -= Math.floor(wallX);
            return { dist: dist || MAX_DEPTH, side, tile: 1, wallX };
        }
        if (tile === 2) { // Normal door
            const door = getDoor(mapX, mapY);
            if (door && door.state < 0.95) {
                if (side === 0) dist = sideDistX - deltaDistX;
                else dist = sideDistY - deltaDistY;
                let wallX;
                if (side === 0) wallX = player.y + dist * sin;
                else wallX = player.x + dist * cos;
                wallX -= Math.floor(wallX);
                return { dist: dist || MAX_DEPTH, side, tile: 2, doorState: door.state, wallX };
            }
        }
        if (tile === 3) { // Elevator door (green)
            const door = getDoor(mapX, mapY);
            if (door && door.state < 0.95) {
                if (side === 0) dist = sideDistX - deltaDistX;
                else dist = sideDistY - deltaDistY;
                let wallX;
                if (side === 0) wallX = player.y + dist * sin;
                else wallX = player.x + dist * cos;
                wallX -= Math.floor(wallX);
                return { dist: dist || MAX_DEPTH, side, tile: 3, doorState: door.state, wallX };
            }
        }
        // Tile 4 (exit portal) is not a wall - rays pass through
    }

    return { dist: MAX_DEPTH, side, tile: 0, wallX: 0 };
}

// Render 3D view
function render3D() {
    // Ceiling - dark spaceship interior with lighting strips (themed)
    const ceilGrad = ctx.createLinearGradient(0, 0, 0, SCREEN_H / 2);
    ceilGrad.addColorStop(0, levelTheme.ceilDark);
    ceilGrad.addColorStop(0.3, levelTheme.ceilMid);
    ceilGrad.addColorStop(0.7, levelTheme.ceilMid);
    ceilGrad.addColorStop(1, levelTheme.ceilLight);
    ctx.fillStyle = ceilGrad;
    ctx.fillRect(0, 0, SCREEN_W, SCREEN_H / 2);

    // Ceiling light strips (themed)
    ctx.fillStyle = levelTheme.stripDark;
    for (let x = 0; x < SCREEN_W; x += 80) {
        ctx.fillRect(x, SCREEN_H / 2 - 8, 40, 6);
    }
    ctx.fillStyle = levelTheme.stripLight;
    for (let x = 0; x < SCREEN_W; x += 80) {
        ctx.fillRect(x + 5, SCREEN_H / 2 - 6, 30, 2);
    }

    // Floor - metallic spaceship floor (themed)
    const floorGrad = ctx.createLinearGradient(0, SCREEN_H / 2, 0, SCREEN_H);
    floorGrad.addColorStop(0, levelTheme.floorLight);
    floorGrad.addColorStop(0.5, levelTheme.floorMid);
    floorGrad.addColorStop(1, levelTheme.floorDark);
    ctx.fillStyle = floorGrad;
    ctx.fillRect(0, SCREEN_H / 2, SCREEN_W, SCREEN_H / 2);


    // Cast rays
    for (let i = 0; i < NUM_RAYS; i++) {
        const rayAngle = player.angle - HALF_FOV + (i / NUM_RAYS) * FOV;
        const { dist, side, tile, doorState, wallX } = castRay(rayAngle);

        // Fix fisheye
        const correctedDist = dist * Math.cos(rayAngle - player.angle);

        // Wall height
        const wallHeight = Math.min(SCREEN_H * 1.5, SCREEN_H / correctedDist);
        const wallTop = (SCREEN_H - wallHeight) / 2;

        // Wall/door color with shading
        const shade = Math.max(0.2, 1 - correctedDist / MAX_DEPTH);
        let r, g, b;

        if (tile === 2) {
            // Metallic door (themed)
            const sideDarken = side === 0 ? 1.0 : 0.85;
            const openAmount = doorState || 0;

            // Door dimensions
            const doorHeight = wallHeight * (1 - openAmount);
            const doorTop = wallTop + (wallHeight - doorHeight);

            // Check for border (edges of door)
            const isBorder = wallX < 0.08 || wallX > 0.92;

            // Check for handle area (right side, middle height)
            const isHandle = wallX > 0.75 && wallX < 0.85;

            if (isBorder) {
                // Darker metallic border (themed)
                const borderLight = levelTheme.doorLight * 0.4 * shade * sideDarken;
                const [br, bg, bb] = hslToRgb(levelTheme.doorHue, levelTheme.doorSat * 0.5, borderLight);
                r = br; g = bg; b = bb;
            } else {
                // Main door panel - themed metallic with subtle variation
                const innerX = (wallX - 0.08) / 0.84;
                const panelPos = (innerX * 2) % 1; // 2 panels
                const edgeDist = Math.min(panelPos, 1 - panelPos);
                const panelShade = 0.9 + edgeDist * 0.2;

                const doorLight = levelTheme.doorLight * shade * panelShade * sideDarken;
                const [dr, dg, db] = hslToRgb(levelTheme.doorHue, levelTheme.doorSat, doorLight);
                r = dr; g = dg; b = db;
            }

            // Draw main door
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect(i * SCALE, doorTop, SCALE + 1, doorHeight);

            // Draw top border (themed)
            const borderSize = doorHeight * 0.06;
            const borderLight = levelTheme.doorLight * 0.4 * shade * sideDarken;
            const [tbr, tbg, tbb] = hslToRgb(levelTheme.doorHue, levelTheme.doorSat * 0.5, borderLight);
            ctx.fillStyle = `rgb(${tbr},${tbg},${tbb})`;
            ctx.fillRect(i * SCALE, doorTop, SCALE + 1, borderSize);

            // Draw handle (themed accent color)
            if (isHandle && doorHeight > 0) {
                const handleTop = doorTop + doorHeight * 0.4;
                const handleHeight = doorHeight * 0.2;
                // Handle base - accent colored
                const handleLight = levelTheme.lightLight * 0.6 * shade;
                const [hr, hg, hb] = hslToRgb(levelTheme.accentHue, levelTheme.lightSat * 0.5, handleLight);
                ctx.fillStyle = `rgb(${hr},${hg},${hb})`;
                ctx.fillRect(i * SCALE, handleTop, SCALE + 1, handleHeight);
                // Handle highlight
                if (wallX > 0.78 && wallX < 0.82) {
                    const highlightLight = levelTheme.lightLight * 0.8 * shade;
                    const [hlr, hlg, hlb] = hslToRgb(levelTheme.accentHue, levelTheme.lightSat * 0.7, highlightLight);
                    ctx.fillStyle = `rgb(${hlr},${hlg},${hlb})`;
                    ctx.fillRect(i * SCALE, handleTop + handleHeight * 0.2, SCALE + 1, handleHeight * 0.6);
                }
            }
        } else if (tile === 3) {
            // Locked door (red when locked, green when player has key)
            const baseColor = side === 0 ? 180 : 150;
            const openAmount = doorState || 0;
            const canOpen = hasKey;

            // Door dimensions
            const doorHeight = wallHeight * (1 - openAmount);
            const doorTop = wallTop + (wallHeight - doorHeight);

            // Check for border
            const isBorder = wallX < 0.06 || wallX > 0.94;

            // Check for lock area (center of door)
            const isLockArea = wallX > 0.42 && wallX < 0.58;

            if (isBorder) {
                // Border color based on lock status
                if (canOpen) {
                    r = Math.floor(80 * shade);
                    g = Math.floor(200 * shade);
                    b = Math.floor(100 * shade);
                } else {
                    r = Math.floor(200 * shade);
                    g = Math.floor(80 * shade);
                    b = Math.floor(60 * shade);
                }
            } else {
                // Inner panel
                const innerX = (wallX - 0.06) / 0.88;
                const panelPos = (innerX * 2) % 1;
                const nearEdge = panelPos < 0.05 || panelPos > 0.95;
                const highlight = nearEdge ? 0.2 : 0;

                if (canOpen) {
                    // Green when player has key
                    r = Math.floor(baseColor * shade * (0.3 + highlight));
                    g = Math.floor(baseColor * shade * (0.9 + highlight * 0.1));
                    b = Math.floor(baseColor * shade * (0.4 + highlight));
                } else {
                    // Red/orange when locked
                    r = Math.floor(baseColor * shade * (1.0 + highlight * 0.1));
                    g = Math.floor(baseColor * shade * (0.35 + highlight));
                    b = Math.floor(baseColor * shade * (0.25 + highlight));
                }
            }

            // Draw main door
            ctx.fillStyle = `rgb(${Math.min(255,r)},${Math.min(255,g)},${Math.min(255,b)})`;
            ctx.fillRect(i * SCALE, doorTop, SCALE + 1, doorHeight);

            // Draw top border
            const borderSize = doorHeight * 0.05;
            if (canOpen) {
                ctx.fillStyle = `rgb(${Math.floor(80 * shade)},${Math.floor(200 * shade)},${Math.floor(100 * shade)})`;
            } else {
                ctx.fillStyle = `rgb(${Math.floor(200 * shade)},${Math.floor(80 * shade)},${Math.floor(60 * shade)})`;
            }
            ctx.fillRect(i * SCALE, doorTop, SCALE + 1, borderSize);

            // Draw lock symbol (keyhole shape in center)
            if (isLockArea && doorHeight > 0) {
                const lockTop = doorTop + doorHeight * 0.35;
                const lockHeight = doorHeight * 0.3;
                // Lock body
                if (canOpen) {
                    ctx.fillStyle = `rgb(${Math.floor(100 * shade)},${Math.floor(180 * shade)},${Math.floor(80 * shade)})`;
                } else {
                    ctx.fillStyle = `rgb(${Math.floor(180 * shade)},${Math.floor(100 * shade)},${Math.floor(50 * shade)})`;
                }
                ctx.fillRect(i * SCALE, lockTop, SCALE + 1, lockHeight);
                // Keyhole (dark center)
                if (wallX > 0.47 && wallX < 0.53) {
                    ctx.fillStyle = `rgb(${Math.floor(30 * shade)},${Math.floor(25 * shade)},${Math.floor(20 * shade)})`;
                    ctx.fillRect(i * SCALE, lockTop + lockHeight * 0.2, SCALE + 1, lockHeight * 0.5);
                }
            }
        } else {
            // Spaceship wall (themed metallic panels)
            const sideDarken = side === 0 ? 1.0 : 0.8;

            // Use wallX for perspective-correct panel pattern (soft gradient)
            const panelPos = (wallX * 2) % 1; // 2 panels per wall tile
            const edgeDist = Math.min(panelPos, 1 - panelPos); // Distance to nearest edge
            const edgeFade = Math.min(1, edgeDist * 8); // Soft falloff near edges

            // Subtle darkening near panel edges, highlight in center
            const panelShade = 0.85 + edgeFade * 0.15;

            // Use themed wall color
            const wallLightness = levelTheme.wallLight * shade * panelShade * sideDarken;
            const [wr, wg, wb] = hslToRgb(levelTheme.wallHue, levelTheme.wallSat, wallLightness);

            ctx.fillStyle = `rgb(${wr},${wg},${wb})`;
            ctx.fillRect(i * SCALE, wallTop, SCALE + 1, wallHeight);
        }

        // Store depth for sprite occlusion
        depthBuffer[i] = correctedDist;
    }

    // Render light sprites
    renderLights();

    // Render victory portal
    renderVictoryPortal();

    // Render ammo boxes
    renderAmmoBoxes();

    // Render health packs
    renderHealthPacks();

    // Render key
    renderKey();

    // Render enemies as sprites
    renderSprites();

    // Render plasma balls
    renderPlasmaBalls();

    // Muzzle flash effect
    if (muzzleFlash > 0) {
        ctx.fillStyle = `rgba(255, 200, 50, ${muzzleFlash * 0.3})`;
        ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);
        muzzleFlash -= 0.2;
    }

    // Damage flash effect (red radial gradient)
    if (damageFlash > 0) {
        const gradient = ctx.createRadialGradient(SCREEN_W / 2, SCREEN_H / 2, 0, SCREEN_W / 2, SCREEN_H / 2, SCREEN_W * 0.7);
        gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
        gradient.addColorStop(0.5, `rgba(255, 0, 0, ${damageFlash * 0.15})`);
        gradient.addColorStop(1, `rgba(200, 0, 0, ${damageFlash * 0.4})`);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);
        damageFlash -= 0.05;
    }

    // Render weapon
    if (currentWeapon === 0) {
        renderHammer();
    } else {
        renderGun();
    }

    // Render HUD
    renderHUD();
}

// Render player's stun baton (sci-fi melee weapon)
function renderHammer() {
    const centerX = SCREEN_W / 2;
    const baseY = SCREEN_H;

    // Scale factor based on screen height (reference: 600px)
    const s = SCREEN_H / 600;

    // Check if baton is cooling down
    const isCoolingDown = shootCooldown > 0 && currentWeapon === 0;

    // Idle bob animation (disabled while cooling down)
    const bobX = isCoolingDown ? 0 : Math.sin(Date.now() * 0.004) * 10 * s;
    const bobY = isCoolingDown ? 0 : Math.abs(Math.cos(Date.now() * 0.008)) * 6 * s;

    // Swing animation (rotates the baton)
    const swingAngle = swingAnimation > 0 ? (1 - swingAnimation / 20) * Math.PI * 0.6 - 0.3 : 0;
    const swingOffsetX = swingAnimation > 0 ? Math.sin(swingAngle) * 100 * s : 0;
    const swingOffsetY = swingAnimation > 0 ? -Math.abs(Math.cos(swingAngle)) * 50 * s : 0;

    const batonX = centerX + bobX + 50 * s + swingOffsetX;
    const batonY = baseY + bobY - 100 * s + swingOffsetY;

    ctx.save();
    ctx.translate(batonX, batonY);
    ctx.scale(s, s);
    ctx.rotate(-0.4 + swingAngle); // Slight tilt + swing

    // Handle (metallic grip)
    ctx.fillStyle = '#2a3040';
    ctx.fillRect(-10, 20, 20, 160);

    // Grip ridges
    ctx.fillStyle = '#1a2030';
    for (let i = 0; i < 6; i++) {
        ctx.fillRect(-12, 40 + i * 22, 24, 8);
    }

    // Main body (sleek metallic)
    ctx.fillStyle = '#4a5565';
    ctx.fillRect(-14, -80, 28, 110);

    // Side panels
    ctx.fillStyle = '#3a4555';
    ctx.fillRect(-16, -70, 6, 90);
    ctx.fillRect(10, -70, 6, 90);

    // Energy prongs (top)
    ctx.fillStyle = '#5a6575';
    ctx.fillRect(-20, -110, 12, 35);
    ctx.fillRect(8, -110, 12, 35);

    // Glowing energy core (dimmed and static while cooling down)
    const glowPulse = isCoolingDown ? 0.3 : 0.6 + 0.4 * Math.sin(Date.now() * 0.015);
    ctx.fillStyle = `rgba(0, 200, 255, ${glowPulse})`;
    ctx.fillRect(-8, -100, 16, 50);

    // Energy between prongs
    ctx.fillStyle = `rgba(0, 255, 255, ${glowPulse * 0.8})`;
    ctx.fillRect(-16, -115, 32, 8);

    // Status light (orange while cooling down, green when ready)
    ctx.fillStyle = isCoolingDown ? '#f80' : '#0f8';
    ctx.fillRect(-4, 10, 8, 8);

    // Electric arc effect when swinging
    if (swingAnimation > 15) {
        ctx.strokeStyle = `rgba(0, 255, 255, ${(swingAnimation - 15) / 5})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-18, -115);
        ctx.lineTo(-25, -140);
        ctx.lineTo(-10, -130);
        ctx.lineTo(-30, -160);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(18, -115);
        ctx.lineTo(25, -140);
        ctx.lineTo(10, -130);
        ctx.lineTo(30, -160);
        ctx.stroke();

        // Glow effect
        ctx.fillStyle = `rgba(0, 255, 255, ${(swingAnimation - 15) / 8})`;
        ctx.beginPath();
        ctx.arc(0, -120, 40, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.restore();

    // Decrease swing animation
    if (swingAnimation > 0) swingAnimation--;
}

// Render player's gun (sci-fi plasma rifle)
function renderGun() {
    const centerX = SCREEN_W / 2;
    const baseY = SCREEN_H + 80; // Lower position so gun doesn't cover as much view

    // Scale factor based on screen height (reference: 600px)
    const s = SCREEN_H / 600;

    // Gun recoil animation
    const recoil = muzzleFlash > 0 ? muzzleFlash * 20 * s : 0;
    const bobX = Math.sin(Date.now() * 0.004) * 12 * s;
    const bobY = Math.abs(Math.cos(Date.now() * 0.008)) * 8 * s;

    const gunX = centerX + bobX;
    const gunY = baseY + bobY - recoil;

    ctx.save();
    ctx.translate(gunX, gunY);
    ctx.scale(s, s);

    // Gun hand/grip (gloved hand)
    ctx.fillStyle = '#2a3040';
    ctx.fillRect(-35, -70, 70, 80);
    ctx.fillStyle = '#1a2030';
    ctx.fillRect(-30, -60, 60, 60);

    // Gun body (main frame - sleek sci-fi)
    ctx.fillStyle = '#3a4555';
    ctx.fillRect(-40, -150, 80, 90);

    // Side panels
    ctx.fillStyle = '#2a3545';
    ctx.fillRect(-42, -145, 10, 75);
    ctx.fillRect(32, -145, 10, 75);

    // Gun barrel (elongated sci-fi)
    ctx.fillStyle = '#4a5565';
    ctx.fillRect(-15, -220, 30, 80);

    // Barrel core (glowing)
    const glowIntensity = 0.5 + 0.3 * Math.sin(Date.now() * 0.01);
    ctx.fillStyle = `rgba(0, 200, 255, ${glowIntensity})`;
    ctx.fillRect(-8, -215, 16, 70);

    // Barrel tip
    ctx.fillStyle = '#5a6575';
    ctx.fillRect(-18, -225, 36, 12);

    // Energy coils on barrel
    ctx.fillStyle = '#0af';
    for (let i = 0; i < 3; i++) {
        ctx.fillRect(-12, -200 + i * 25, 24, 3);
    }

    // Top rail
    ctx.fillStyle = '#4a5060';
    ctx.fillRect(-10, -165, 20, 8);

    // Side lights
    ctx.fillStyle = muzzleFlash > 0 ? '#f80' : '#0a8';
    ctx.fillRect(-38, -130, 6, 20);
    ctx.fillRect(32, -130, 6, 20);

    // Muzzle flash (plasma burst)
    if (muzzleFlash > 0.5) {
        ctx.fillStyle = '#0ff';
        ctx.beginPath();
        ctx.moveTo(0, -230);
        ctx.lineTo(-25, -270);
        ctx.lineTo(-6, -240);
        ctx.lineTo(0, -300);
        ctx.lineTo(6, -240);
        ctx.lineTo(25, -270);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(0, -230, 15, 0, Math.PI * 2);
        ctx.fill();

        // Plasma glow
        ctx.fillStyle = `rgba(0, 255, 255, ${muzzleFlash * 0.3})`;
        ctx.beginPath();
        ctx.arc(0, -230, 40, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.restore();
}

// Render HUD at bottom of screen (Doom-style)
function renderHUD() {
    // Scale factor based on screen height (reference: 600px)
    const s = Math.min(1, SCREEN_H / 600);
    const hudHeight = Math.floor(60 * s);
    const hudY = SCREEN_H - hudHeight;

    // HUD background (dark metallic panel)
    const hudGrad = ctx.createLinearGradient(0, hudY, 0, SCREEN_H);
    hudGrad.addColorStop(0, '#2a3040');
    hudGrad.addColorStop(0.1, '#1a2030');
    hudGrad.addColorStop(1, '#0a1020');
    ctx.fillStyle = hudGrad;
    ctx.fillRect(0, hudY, SCREEN_W, hudHeight);

    // Top border line
    ctx.fillStyle = '#4a6080';
    ctx.fillRect(0, hudY, SCREEN_W, 2);

    // Panel dividers (scaled positions)
    ctx.fillStyle = '#3a4050';
    ctx.fillRect(SCREEN_W * 0.25, hudY + 5 * s, 2, hudHeight - 10 * s);
    ctx.fillRect(SCREEN_W * 0.75, hudY + 5 * s, 2, hudHeight - 10 * s);

    // Update head look direction based on player turning
    const angleDiff = player.angle - lastPlayerAngle;
    if (Math.abs(angleDiff) > 0.02) {
        headLookDir = angleDiff > 0 ? 1 : -1;
        headLookTimer = 30;
    }
    lastPlayerAngle = player.angle;

    if (headLookTimer > 0) {
        headLookTimer--;
    } else {
        headLookDir = 0;
    }

    // Draw space-man head (center of HUD)
    const headX = SCREEN_W / 2;
    const headY = hudY + hudHeight / 2 + 2 * s;
    const headSize = 22 * s;

    ctx.save();
    ctx.translate(headX, headY);

    // Helmet (outer)
    ctx.fillStyle = '#4a5565';
    ctx.beginPath();
    ctx.arc(0, 0, headSize, 0, Math.PI * 2);
    ctx.fill();

    // Helmet rim
    ctx.fillStyle = '#3a4555';
    ctx.beginPath();
    ctx.arc(0, 0, headSize - 3 * s, 0, Math.PI * 2);
    ctx.fill();

    // Visor (dark)
    ctx.fillStyle = '#1a2535';
    ctx.beginPath();
    ctx.ellipse(0, 2 * s, headSize - 6 * s, headSize - 8 * s, 0, 0, Math.PI * 2);
    ctx.fill();

    // Visor reflection
    ctx.fillStyle = 'rgba(100, 180, 220, 0.3)';
    ctx.beginPath();
    ctx.ellipse(-5 * s, -2 * s, 6 * s, 4 * s, -0.3, 0, Math.PI * 2);
    ctx.fill();

    // Face inside visor
    const faceOffsetX = headLookDir * 4 * s;
    ctx.fillStyle = headDamageFlash > 0 ? '#ff8866' : '#e8c8a8';
    ctx.beginPath();
    ctx.ellipse(faceOffsetX, 3 * s, 10 * s, 12 * s, 0, 0, Math.PI * 2);
    ctx.fill();

    // Eyes
    const eyeOffsetX = headLookDir * 2 * s;
    ctx.fillStyle = '#222';
    ctx.fillRect(faceOffsetX - 5 * s + eyeOffsetX, -1 * s, 3 * s, 4 * s);
    ctx.fillRect(faceOffsetX + 2 * s + eyeOffsetX, -1 * s, 3 * s, 4 * s);

    // Eye whites/direction
    ctx.fillStyle = '#fff';
    ctx.fillRect(faceOffsetX - 5 * s + eyeOffsetX + (headLookDir > 0 ? 1 * s : 0), 0, 2 * s, 2 * s);
    ctx.fillRect(faceOffsetX + 2 * s + eyeOffsetX + (headLookDir > 0 ? 1 * s : 0), 0, 2 * s, 2 * s);

    // Mouth (changes with health)
    ctx.fillStyle = '#833';
    if (player.health > 60) {
        // Slight smile
        ctx.beginPath();
        ctx.arc(faceOffsetX, 10 * s, 4 * s, 0.1 * Math.PI, 0.9 * Math.PI);
        ctx.stroke();
    } else if (player.health > 30) {
        // Neutral
        ctx.fillRect(faceOffsetX - 3 * s, 9 * s, 6 * s, 2 * s);
    } else {
        // Grimace
        ctx.beginPath();
        ctx.arc(faceOffsetX, 12 * s, 4 * s, 1.1 * Math.PI, 1.9 * Math.PI);
        ctx.stroke();
    }

    // Helmet lights
    ctx.fillStyle = player.health > 30 ? '#0f8' : '#f44';
    ctx.fillRect(-headSize + 4 * s, -8 * s, 4 * s, 4 * s);
    ctx.fillRect(headSize - 8 * s, -8 * s, 4 * s, 4 * s);

    ctx.restore();

    // Decrease damage flash
    if (headDamageFlash > 0) headDamageFlash--;

    // Left panel - Health
    ctx.fillStyle = '#0cf';
    ctx.font = `bold ${Math.floor(14 * s)}px monospace`;
    ctx.textAlign = 'left';
    ctx.fillText('HEALTH', 15 * s, hudY + 20 * s);

    const healthColor = player.health > 60 ? '#0f8' : player.health > 30 ? '#fa0' : '#f44';
    ctx.fillStyle = healthColor;
    ctx.font = `bold ${Math.floor(28 * s)}px monospace`;
    ctx.fillText(Math.floor(player.health), 15 * s, hudY + 48 * s);

    // Health bar
    ctx.fillStyle = '#1a2030';
    ctx.fillRect(90 * s, hudY + 30 * s, 100 * s, 16 * s);
    ctx.fillStyle = healthColor;
    ctx.fillRect(92 * s, hudY + 32 * s, Math.max(0, (player.health / 100) * 96 * s), 12 * s);

    // Right panel - Ammo & Kills
    ctx.fillStyle = '#0cf';
    ctx.font = `bold ${Math.floor(14 * s)}px monospace`;
    ctx.textAlign = 'right';
    ctx.fillText('PLASMA', SCREEN_W - 15 * s, hudY + 20 * s);
    ctx.fillText('KILLS', SCREEN_W - 100 * s, hudY + 20 * s);

    ctx.fillStyle = currentWeapon === 1 ? '#0cf' : '#446';
    ctx.font = `bold ${Math.floor(28 * s)}px monospace`;
    ctx.fillText(player.ammo, SCREEN_W - 15 * s, hudY + 48 * s);

    ctx.fillStyle = '#f4a';
    ctx.fillText(player.kills, SCREEN_W - 100 * s, hudY + 48 * s);

    // Level indicator
    ctx.fillStyle = '#fa0';
    ctx.font = `bold ${Math.floor(12 * s)}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillText(`LEVEL ${currentLevel}`, SCREEN_W / 2, hudY + 15 * s);

    // Key indicator (between head and right panel)
    const keyX = SCREEN_W * 0.62;
    const keyY = hudY + hudHeight / 2;
    const keySize = 12 * s;

    if (hasKey) {
        // Golden key icon when collected
        ctx.fillStyle = '#fc0';
        ctx.fillRect(keyX - keySize * 0.3, keyY - keySize * 0.6, keySize * 0.6, keySize * 0.4);
        ctx.fillStyle = '#da0';
        ctx.fillRect(keyX - keySize * 0.15, keyY - keySize * 0.2, keySize * 0.3, keySize * 0.8);
        ctx.fillRect(keyX, keyY + keySize * 0.3, keySize * 0.3, keySize * 0.15);
        // "KEY" label
        ctx.fillStyle = '#fc0';
        ctx.font = `bold ${Math.floor(10 * s)}px monospace`;
        ctx.textAlign = 'center';
        ctx.fillText('KEY', keyX, keyY + keySize * 0.9);
    } else {
        // Grey key outline when not collected
        ctx.fillStyle = '#445';
        ctx.fillRect(keyX - keySize * 0.3, keyY - keySize * 0.6, keySize * 0.6, keySize * 0.4);
        ctx.fillRect(keyX - keySize * 0.15, keyY - keySize * 0.2, keySize * 0.3, keySize * 0.8);
        ctx.fillRect(keyX, keyY + keySize * 0.3, keySize * 0.3, keySize * 0.15);
        // "KEY" label (dimmed)
        ctx.fillStyle = '#445';
        ctx.font = `bold ${Math.floor(10 * s)}px monospace`;
        ctx.textAlign = 'center';
        ctx.fillText('KEY', keyX, keyY + keySize * 0.9);
    }

    // Weapon indicator
    ctx.fillStyle = '#5a6a7a';
    ctx.font = `bold ${Math.floor(12 * s)}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillText(currentWeapon === 0 ? '[ BATON ]' : '[ RIFLE ]', SCREEN_W / 2, hudY + 55 * s);
}

// Render light sprites
function renderLights() {
    const lightData = lights.map(light => {
        const dx = light.x - player.x;
        const dy = light.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) - player.angle;
        return { light, dist, angle };
    });

    // Sort by distance (far to near)
    lightData.sort((a, b) => b.dist - a.dist);

    // Get themed light colors
    const lr = levelTheme.lightR;
    const lg = levelTheme.lightG;
    const lb = levelTheme.lightB;

    for (const { light, dist, angle } of lightData) {
        let normAngle = angle;
        while (normAngle > Math.PI) normAngle -= 2 * Math.PI;
        while (normAngle < -Math.PI) normAngle += 2 * Math.PI;

        if (Math.abs(normAngle) > HALF_FOV + 0.2) continue;

        const screenX = (0.5 + normAngle / FOV) * SCREEN_W;
        const spriteSize = Math.min(SCREEN_H * 0.3, (SCREEN_H * 0.15) / dist);
        const spriteTop = SCREEN_H / 2 - spriteSize * 1.5; // Position higher (wall-mounted)

        // Check depth - only draw if not behind wall
        const col = Math.floor(screenX / SCALE);
        if (col >= 0 && col < NUM_RAYS && depthBuffer[col] < dist) continue;

        // Flicker effect
        const flicker = 0.7 + 0.3 * Math.sin(Date.now() * 0.008 + light.phase);
        const glowSize = spriteSize * (1.5 + 0.2 * Math.sin(Date.now() * 0.005 + light.phase));

        // Outer glow (themed)
        const gradient = ctx.createRadialGradient(screenX, spriteTop + spriteSize / 2, 0, screenX, spriteTop + spriteSize / 2, glowSize);
        gradient.addColorStop(0, `rgba(${lr}, ${lg}, ${lb}, ${0.4 * flicker})`);
        gradient.addColorStop(0.4, `rgba(${Math.floor(lr * 0.7)}, ${Math.floor(lg * 0.7)}, ${Math.floor(lb * 0.7)}, ${0.2 * flicker})`);
        gradient.addColorStop(1, `rgba(${Math.floor(lr * 0.4)}, ${Math.floor(lg * 0.4)}, ${Math.floor(lb * 0.4)}, 0)`);
        ctx.fillStyle = gradient;
        ctx.fillRect(screenX - glowSize, spriteTop + spriteSize / 2 - glowSize, glowSize * 2, glowSize * 2);

        // Light fixture (small rectangle - themed)
        const [fr, fg, fb] = hslToRgb(levelTheme.wallHue, levelTheme.wallSat * 0.8, levelTheme.wallLight * 1.5);
        ctx.fillStyle = `rgba(${fr}, ${fg}, ${fb}, ${flicker})`;
        ctx.fillRect(screenX - spriteSize * 0.4, spriteTop, spriteSize * 0.8, spriteSize * 0.5);

        // Bright center (themed)
        const brightR = Math.min(255, lr + 100);
        const brightG = Math.min(255, lg + 100);
        const brightB = Math.min(255, lb + 100);
        ctx.fillStyle = `rgba(${brightR}, ${brightG}, ${brightB}, ${flicker})`;
        ctx.fillRect(screenX - spriteSize * 0.25, spriteTop + spriteSize * 0.15, spriteSize * 0.5, spriteSize * 0.25);
    }
}

// Render victory portal sprite at exit location
function renderVictoryPortal() {
    const portalX = ELEVATOR.x + 0.5;
    const portalY = ELEVATOR.y + 0.5;

    const dx = portalX - player.x;
    const dy = portalY - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    let angle = Math.atan2(dy, dx) - player.angle;

    // Normalize angle
    while (angle > Math.PI) angle -= 2 * Math.PI;
    while (angle < -Math.PI) angle += 2 * Math.PI;

    // Skip if behind player or too far to side
    if (Math.abs(angle) > HALF_FOV + 0.3) return;

    const screenX = (0.5 + angle / FOV) * SCREEN_W;
    const spriteHeight = Math.min(SCREEN_H * 1.5, SCREEN_H / dist);
    const spriteWidth = spriteHeight * 0.8;
    const spriteTop = (SCREEN_H - spriteHeight) / 2;

    // Check if behind wall (use center column)
    const col = Math.floor(screenX / SCALE);
    if (col >= 0 && col < NUM_RAYS && depthBuffer[col] < dist) return;

    // Animated pulse
    const time = Date.now() * 0.003;
    const pulse = 0.7 + 0.3 * Math.sin(time);
    const rotationPhase = time * 0.5;

    // Outer glow (large, soft)
    const glowSize = spriteHeight * 1.2;
    const outerGlow = ctx.createRadialGradient(screenX, SCREEN_H / 2, 0, screenX, SCREEN_H / 2, glowSize);
    outerGlow.addColorStop(0, `rgba(100, 255, 150, ${0.4 * pulse})`);
    outerGlow.addColorStop(0.3, `rgba(50, 255, 100, ${0.25 * pulse})`);
    outerGlow.addColorStop(0.6, `rgba(0, 200, 100, ${0.1 * pulse})`);
    outerGlow.addColorStop(1, 'rgba(0, 150, 50, 0)');
    ctx.fillStyle = outerGlow;
    ctx.beginPath();
    ctx.arc(screenX, SCREEN_H / 2, glowSize, 0, Math.PI * 2);
    ctx.fill();

    // Inner portal (bright core)
    const innerSize = spriteHeight * 0.5;
    const innerGlow = ctx.createRadialGradient(screenX, SCREEN_H / 2, 0, screenX, SCREEN_H / 2, innerSize);
    innerGlow.addColorStop(0, `rgba(255, 255, 255, ${0.9 * pulse})`);
    innerGlow.addColorStop(0.3, `rgba(150, 255, 200, ${0.7 * pulse})`);
    innerGlow.addColorStop(0.7, `rgba(50, 255, 150, ${0.4 * pulse})`);
    innerGlow.addColorStop(1, 'rgba(0, 200, 100, 0)');
    ctx.fillStyle = innerGlow;
    ctx.beginPath();
    ctx.arc(screenX, SCREEN_H / 2, innerSize, 0, Math.PI * 2);
    ctx.fill();

    // Rotating energy rings
    ctx.strokeStyle = `rgba(100, 255, 180, ${0.6 * pulse})`;
    ctx.lineWidth = 2;
    for (let i = 0; i < 3; i++) {
        const ringPhase = rotationPhase + (i * Math.PI * 2 / 3);
        const ringSize = spriteHeight * (0.3 + i * 0.15);
        const squeeze = 0.3 + 0.2 * Math.sin(ringPhase);

        ctx.beginPath();
        ctx.ellipse(screenX, SCREEN_H / 2, ringSize, ringSize * squeeze, ringPhase, 0, Math.PI * 2);
        ctx.stroke();
    }

    // Sparkles
    ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
    for (let i = 0; i < 6; i++) {
        const sparkAngle = rotationPhase * 2 + (i * Math.PI / 3);
        const sparkDist = spriteHeight * (0.25 + 0.1 * Math.sin(time * 2 + i));
        const sparkX = screenX + Math.cos(sparkAngle) * sparkDist;
        const sparkY = SCREEN_H / 2 + Math.sin(sparkAngle) * sparkDist * 0.5;
        const sparkSize = 3 + 2 * Math.sin(time * 3 + i);

        ctx.beginPath();
        ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
        ctx.fill();
    }

    // "EXIT" text above portal
    const textY = spriteTop + spriteHeight * 0.1;
    const fontSize = Math.max(12, Math.floor(spriteHeight * 0.12));
    ctx.font = `bold ${fontSize}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillStyle = `rgba(150, 255, 200, ${0.8 + 0.2 * Math.sin(time * 2)})`;
    ctx.fillText('EXIT', screenX, textY);
}

// Render ammo box sprites
function renderAmmoBoxes() {
    const boxData = ammoBoxes.filter(b => !b.collected).map(box => {
        const dx = box.x - player.x;
        const dy = box.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) - player.angle;
        return { box, dist, angle };
    });

    // Sort by distance (far to near)
    boxData.sort((a, b) => b.dist - a.dist);

    for (const { box, dist, angle } of boxData) {
        let normAngle = angle;
        while (normAngle > Math.PI) normAngle -= 2 * Math.PI;
        while (normAngle < -Math.PI) normAngle += 2 * Math.PI;

        if (Math.abs(normAngle) > HALF_FOV + 0.2) continue;

        const screenX = (0.5 + normAngle / FOV) * SCREEN_W;
        const spriteSize = Math.min(SCREEN_H * 0.4, (SCREEN_H * 0.2) / dist);
        const spriteTop = SCREEN_H / 2 + spriteSize * 0.3; // On the floor

        // Check depth - only draw if not behind wall
        const col = Math.floor(screenX / SCALE);
        if (col >= 0 && col < NUM_RAYS && depthBuffer[col] < dist) continue;

        const shade = Math.max(0.3, 1 - dist / MAX_DEPTH);
        const bob = Math.sin(Date.now() * 0.005) * spriteSize * 0.1;

        // Box body (green ammo crate)
        ctx.fillStyle = `rgb(${Math.floor(40 * shade)}, ${Math.floor(120 * shade)}, ${Math.floor(50 * shade)})`;
        ctx.fillRect(screenX - spriteSize * 0.4, spriteTop - spriteSize * 0.6 + bob, spriteSize * 0.8, spriteSize * 0.6);

        // Box highlight
        ctx.fillStyle = `rgb(${Math.floor(60 * shade)}, ${Math.floor(180 * shade)}, ${Math.floor(80 * shade)})`;
        ctx.fillRect(screenX - spriteSize * 0.35, spriteTop - spriteSize * 0.55 + bob, spriteSize * 0.3, spriteSize * 0.15);

        // Ammo symbol (yellow rectangle)
        ctx.fillStyle = `rgb(${Math.floor(220 * shade)}, ${Math.floor(200 * shade)}, ${Math.floor(50 * shade)})`;
        ctx.fillRect(screenX - spriteSize * 0.15, spriteTop - spriteSize * 0.45 + bob, spriteSize * 0.3, spriteSize * 0.25);

        // Glow effect
        const glowSize = spriteSize * 0.8;
        const gradient = ctx.createRadialGradient(screenX, spriteTop - spriteSize * 0.3 + bob, 0, screenX, spriteTop - spriteSize * 0.3 + bob, glowSize);
        gradient.addColorStop(0, `rgba(100, 255, 100, ${0.2 * shade})`);
        gradient.addColorStop(1, 'rgba(50, 200, 50, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(screenX - glowSize, spriteTop - spriteSize * 0.3 - glowSize + bob, glowSize * 2, glowSize * 2);
    }
}

// Render health pack sprites
function renderHealthPacks() {
    const packData = healthPacks.filter(p => !p.collected).map(pack => {
        const dx = pack.x - player.x;
        const dy = pack.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) - player.angle;
        return { pack, dist, angle };
    });

    // Sort by distance (far to near)
    packData.sort((a, b) => b.dist - a.dist);

    for (const { pack, dist, angle } of packData) {
        let normAngle = angle;
        while (normAngle > Math.PI) normAngle -= 2 * Math.PI;
        while (normAngle < -Math.PI) normAngle += 2 * Math.PI;

        if (Math.abs(normAngle) > HALF_FOV + 0.2) continue;

        const screenX = (0.5 + normAngle / FOV) * SCREEN_W;
        const spriteSize = Math.min(SCREEN_H * 0.4, (SCREEN_H * 0.2) / dist);
        const spriteTop = SCREEN_H / 2 + spriteSize * 0.3; // On the floor

        // Check depth - only draw if not behind wall
        const col = Math.floor(screenX / SCALE);
        if (col >= 0 && col < NUM_RAYS && depthBuffer[col] < dist) continue;

        const shade = Math.max(0.3, 1 - dist / MAX_DEPTH);
        const bob = Math.sin(Date.now() * 0.006 + 1) * spriteSize * 0.1;

        // Box body (red/white medical crate)
        ctx.fillStyle = `rgb(${Math.floor(200 * shade)}, ${Math.floor(50 * shade)}, ${Math.floor(50 * shade)})`;
        ctx.fillRect(screenX - spriteSize * 0.4, spriteTop - spriteSize * 0.6 + bob, spriteSize * 0.8, spriteSize * 0.6);

        // White cross (horizontal)
        ctx.fillStyle = `rgb(${Math.floor(255 * shade)}, ${Math.floor(255 * shade)}, ${Math.floor(255 * shade)})`;
        ctx.fillRect(screenX - spriteSize * 0.25, spriteTop - spriteSize * 0.38 + bob, spriteSize * 0.5, spriteSize * 0.15);

        // White cross (vertical)
        ctx.fillRect(screenX - spriteSize * 0.1, spriteTop - spriteSize * 0.52 + bob, spriteSize * 0.2, spriteSize * 0.42);

        // Glow effect
        const glowSize = spriteSize * 0.8;
        const gradient = ctx.createRadialGradient(screenX, spriteTop - spriteSize * 0.3 + bob, 0, screenX, spriteTop - spriteSize * 0.3 + bob, glowSize);
        gradient.addColorStop(0, `rgba(255, 100, 100, ${0.2 * shade})`);
        gradient.addColorStop(1, 'rgba(200, 50, 50, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(screenX - glowSize, spriteTop - spriteSize * 0.3 - glowSize + bob, glowSize * 2, glowSize * 2);
    }
}

// Render key sprite
function renderKey() {
    if (levelKey.collected) return;

    const dx = levelKey.x - player.x;
    const dy = levelKey.y - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    let angle = Math.atan2(dy, dx) - player.angle;

    // Normalize angle
    while (angle > Math.PI) angle -= 2 * Math.PI;
    while (angle < -Math.PI) angle += 2 * Math.PI;

    if (Math.abs(angle) > HALF_FOV + 0.2) return;

    const screenX = (0.5 + angle / FOV) * SCREEN_W;
    const spriteSize = Math.min(SCREEN_H * 0.5, (SCREEN_H * 0.25) / dist);
    const spriteTop = SCREEN_H / 2 + spriteSize * 0.1; // Floating slightly

    // Check depth - only draw if not behind wall
    const col = Math.floor(screenX / SCALE);
    if (col >= 0 && col < NUM_RAYS && depthBuffer[col] < dist) return;

    const shade = Math.max(0.4, 1 - dist / MAX_DEPTH);
    const time = Date.now() * 0.003;
    const bob = Math.sin(time * 2) * spriteSize * 0.15;
    const pulse = 0.8 + 0.2 * Math.sin(time * 3);

    // Outer glow (golden)
    const glowSize = spriteSize * 1.2;
    const outerGlow = ctx.createRadialGradient(screenX, spriteTop - spriteSize * 0.2 + bob, 0, screenX, spriteTop - spriteSize * 0.2 + bob, glowSize);
    outerGlow.addColorStop(0, `rgba(255, 220, 100, ${0.4 * shade * pulse})`);
    outerGlow.addColorStop(0.5, `rgba(255, 180, 50, ${0.2 * shade * pulse})`);
    outerGlow.addColorStop(1, 'rgba(200, 150, 0, 0)');
    ctx.fillStyle = outerGlow;
    ctx.beginPath();
    ctx.arc(screenX, spriteTop - spriteSize * 0.2 + bob, glowSize, 0, Math.PI * 2);
    ctx.fill();

    // Key body (golden rectangle - the bow)
    const keyWidth = spriteSize * 0.3;
    const keyHeight = spriteSize * 0.5;
    ctx.fillStyle = `rgb(${Math.floor(220 * shade)}, ${Math.floor(180 * shade)}, ${Math.floor(50 * shade)})`;
    ctx.fillRect(screenX - keyWidth / 2, spriteTop - keyHeight + bob, keyWidth, keyHeight * 0.4);

    // Key bow hole (dark center)
    ctx.fillStyle = `rgb(${Math.floor(60 * shade)}, ${Math.floor(50 * shade)}, ${Math.floor(20 * shade)})`;
    ctx.fillRect(screenX - keyWidth * 0.15, spriteTop - keyHeight * 0.8 + bob, keyWidth * 0.3, keyHeight * 0.2);

    // Key shaft
    ctx.fillStyle = `rgb(${Math.floor(200 * shade)}, ${Math.floor(160 * shade)}, ${Math.floor(40 * shade)})`;
    ctx.fillRect(screenX - keyWidth * 0.12, spriteTop - keyHeight * 0.6 + bob, keyWidth * 0.24, keyHeight * 0.8);

    // Key teeth
    ctx.fillStyle = `rgb(${Math.floor(180 * shade)}, ${Math.floor(140 * shade)}, ${Math.floor(30 * shade)})`;
    ctx.fillRect(screenX - keyWidth * 0.12, spriteTop + keyHeight * 0.1 + bob, keyWidth * 0.4, keyHeight * 0.1);
    ctx.fillRect(screenX + keyWidth * 0.1, spriteTop + keyHeight * 0.0 + bob, keyWidth * 0.15, keyHeight * 0.15);

    // Highlight
    ctx.fillStyle = `rgba(255, 255, 200, ${0.4 * shade * pulse})`;
    ctx.fillRect(screenX - keyWidth * 0.4, spriteTop - keyHeight * 0.9 + bob, keyWidth * 0.15, keyHeight * 0.25);

    // Sparkles around key
    ctx.fillStyle = `rgba(255, 255, 200, ${pulse * shade})`;
    for (let i = 0; i < 4; i++) {
        const sparkAngle = time * 2 + (i * Math.PI / 2);
        const sparkDist = spriteSize * (0.4 + 0.1 * Math.sin(time * 3 + i));
        const sparkX = screenX + Math.cos(sparkAngle) * sparkDist;
        const sparkY = spriteTop - spriteSize * 0.2 + bob + Math.sin(sparkAngle) * sparkDist * 0.5;
        const sparkSize = 2 + Math.sin(time * 4 + i) * 1.5;

        ctx.beginPath();
        ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Render plasma ball projectiles
function renderPlasmaBalls() {
    for (const ball of plasmaBalls) {
        if (!ball.alive) continue;

        const dx = ball.x - player.x;
        const dy = ball.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        let angle = Math.atan2(dy, dx) - player.angle;

        while (angle > Math.PI) angle -= 2 * Math.PI;
        while (angle < -Math.PI) angle += 2 * Math.PI;

        if (Math.abs(angle) > HALF_FOV + 0.3) continue;

        const screenX = (0.5 + angle / FOV) * SCREEN_W;
        const spriteSize = Math.min(SCREEN_H * 0.5, (SCREEN_H * 0.15) / dist);

        // Check depth
        const col = Math.floor(screenX / SCALE);
        if (col >= 0 && col < NUM_RAYS && depthBuffer[col] < dist) continue;

        const pulse = 0.7 + 0.3 * Math.sin(Date.now() * 0.02);

        // Outer glow
        const glowSize = spriteSize * 2;
        const gradient = ctx.createRadialGradient(screenX, SCREEN_H / 2, 0, screenX, SCREEN_H / 2, glowSize);
        gradient.addColorStop(0, `rgba(100, 200, 255, ${0.8 * pulse})`);
        gradient.addColorStop(0.3, `rgba(50, 150, 255, ${0.4 * pulse})`);
        gradient.addColorStop(1, 'rgba(0, 100, 200, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(screenX, SCREEN_H / 2, glowSize, 0, Math.PI * 2);
        ctx.fill();

        // Core
        ctx.fillStyle = `rgba(200, 240, 255, ${pulse})`;
        ctx.beginPath();
        ctx.arc(screenX, SCREEN_H / 2, spriteSize * 0.5, 0, Math.PI * 2);
        ctx.fill();

        // Bright center
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(screenX, SCREEN_H / 2, spriteSize * 0.2, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Render enemy sprites
function renderSprites() {
    // Calculate distance and angle for each enemy (include dying enemies)
    const spriteData = enemies.filter(e => e.alive || e.dying).map(enemy => {
        const dx = enemy.x - player.x;
        const dy = enemy.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) - player.angle;
        return { enemy, dist, angle };
    });

    // Sort by distance (far to near)
    spriteData.sort((a, b) => b.dist - a.dist);

    // Render each sprite
    for (const { enemy, dist, angle } of spriteData) {
        // Normalize angle to -PI to PI
        let normAngle = angle;
        while (normAngle > Math.PI) normAngle -= 2 * Math.PI;
        while (normAngle < -Math.PI) normAngle += 2 * Math.PI;

        // Skip if behind player or too far to side
        if (Math.abs(normAngle) > HALF_FOV + 0.3) continue;

        // Screen position
        const screenX = (0.5 + normAngle / FOV) * SCREEN_W;

        // Death animation parameters
        const deathProgress = enemy.dying ? enemy.deathTimer / 30 : 0; // 30 frames to die
        const collapse = deathProgress; // 0 to 1
        const tilt = deathProgress * 0.5; // Tilt/lean as they fall

        // Sprite size based on distance (shrink vertically when dying)
        const baseHeight = Math.min(SCREEN_H * 1.2, SCREEN_H / dist);
        const spriteHeight = baseHeight * (1 - collapse * 0.7);
        const spriteWidth = baseHeight * 0.6 * (1 + collapse * 0.3); // Spread out as they fall
        const spriteTop = (SCREEN_H - baseHeight) / 2 + (baseHeight - spriteHeight);

        // Draw sprite column by column (for proper depth testing)
        const startCol = Math.floor((screenX - spriteWidth / 2) / SCALE);
        const endCol = Math.floor((screenX + spriteWidth / 2) / SCALE);

        let visibleOnScreen = false;

        for (let col = startCol; col <= endCol; col++) {
            if (col < 0 || col >= NUM_RAYS) continue;
            if (depthBuffer[col] < dist) continue; // Behind wall

            // Enemy is visible (not behind wall)
            visibleOnScreen = true;

            const spriteX = col * SCALE;
            const colRatio = (col - startCol) / (endCol - startCol);

            // Draw enemy as alien creature
            const shade = Math.max(0.3, 1 - dist / MAX_DEPTH);

            // Body color (themed, turns darker when dying)
            const deathColor = enemy.dying ? collapse : 0;

            // Calculate body color using theme with variation across the sprite
            const bodyVariation = Math.sin(colRatio * Math.PI) * 15;
            const bodyLightness = levelTheme.enemyLight * shade * (1 - deathColor * 0.5) + bodyVariation * shade;
            const bodySaturation = levelTheme.enemySat * (1 - deathColor * 0.3);
            const [r, g, b] = hslToRgb(levelTheme.enemyHue, bodySaturation, bodyLightness);

            // Draw column of sprite with death deformation
            let colHeight = spriteHeight * getEnemyShape(colRatio);

            // Add wobble/collapse effect when dying
            if (enemy.dying) {
                const wobble = Math.sin(colRatio * Math.PI * 4 + enemy.deathTimer * 0.3) * collapse * 10;
                colHeight *= (1 - Math.abs(colRatio - 0.5) * collapse);
            }

            const colTop = spriteTop + (spriteHeight - colHeight);

            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect(spriteX, colTop, SCALE + 1, colHeight);

            // Glowing eyes (themed, position varies by shape) - fade out when dying
            if (!enemy.dying) {
                let drawEyes = false;
                let eyeYOffset = 0.2;
                let eyeSize = spriteHeight * 0.08;

                switch (levelTheme.enemyShape) {
                    case 'humanoid':
                        drawEyes = (colRatio > 0.25 && colRatio < 0.4) || (colRatio > 0.6 && colRatio < 0.75);
                        eyeYOffset = 0.2;
                        break;
                    case 'blob':
                        // Multiple small eyes scattered
                        drawEyes = (colRatio > 0.3 && colRatio < 0.38) || (colRatio > 0.45 && colRatio < 0.55) || (colRatio > 0.62 && colRatio < 0.7);
                        eyeYOffset = 0.25 + Math.sin(colRatio * Math.PI * 3) * 0.1;
                        eyeSize = spriteHeight * 0.06;
                        break;
                    case 'insectoid':
                        // Large compound eyes
                        drawEyes = (colRatio > 0.35 && colRatio < 0.45) || (colRatio > 0.55 && colRatio < 0.65);
                        eyeYOffset = 0.15;
                        eyeSize = spriteHeight * 0.12;
                        break;
                    case 'tall':
                        // Small, high-set eyes
                        drawEyes = (colRatio > 0.4 && colRatio < 0.47) || (colRatio > 0.53 && colRatio < 0.6);
                        eyeYOffset = 0.1;
                        eyeSize = spriteHeight * 0.05;
                        break;
                    case 'squat':
                        // Wide-set glowing eyes
                        drawEyes = (colRatio > 0.2 && colRatio < 0.35) || (colRatio > 0.65 && colRatio < 0.8);
                        eyeYOffset = 0.25;
                        eyeSize = spriteHeight * 0.1;
                        break;
                    case 'spider':
                        // Multiple eyes in a row
                        drawEyes = (colRatio > 0.35 && colRatio < 0.4) || (colRatio > 0.43 && colRatio < 0.48) ||
                                   (colRatio > 0.52 && colRatio < 0.57) || (colRatio > 0.6 && colRatio < 0.65);
                        eyeYOffset = 0.18;
                        eyeSize = spriteHeight * 0.055;
                        break;
                }

                if (drawEyes) {
                    const eyeY = spriteTop + spriteHeight * eyeYOffset;
                    const [eyeR, eyeG, eyeB] = hslToRgb(levelTheme.enemyEyeHue, 100, 60 * shade);
                    ctx.fillStyle = `rgb(${eyeR}, ${eyeG}, ${eyeB})`;
                    ctx.fillRect(spriteX, eyeY, SCALE + 1, eyeSize);
                }
            }

            // Alien markings/patterns (themed glow, varies by shape)
            if (!enemy.dying && colRatio > 0.3 && colRatio < 0.7) {
                let drawMarking = false;
                let markYOffset = 0.5;
                let markSize = spriteHeight * 0.15;

                switch (levelTheme.enemyShape) {
                    case 'humanoid':
                        drawMarking = (col % 4 === 0);
                        break;
                    case 'blob':
                        // Bioluminescent spots
                        drawMarking = (col % 3 === 0);
                        markYOffset = 0.4 + Math.sin(colRatio * Math.PI * 5) * 0.15;
                        markSize = spriteHeight * 0.1;
                        break;
                    case 'insectoid':
                        // Segmented markings
                        drawMarking = (col % 2 === 0);
                        markYOffset = 0.55;
                        markSize = spriteHeight * 0.08;
                        break;
                    case 'tall':
                        // Vertical stripe patterns
                        drawMarking = (col % 5 === 0);
                        markYOffset = 0.35;
                        markSize = spriteHeight * 0.25;
                        break;
                    case 'squat':
                        // Armor plate markings
                        drawMarking = (col % 3 === 0);
                        markYOffset = 0.45;
                        markSize = spriteHeight * 0.2;
                        break;
                    case 'spider':
                        // Carapace patterns
                        drawMarking = (col % 4 === 0) && colRatio > 0.4 && colRatio < 0.6;
                        markYOffset = 0.5;
                        markSize = spriteHeight * 0.12;
                        break;
                }

                if (drawMarking) {
                    const markY = spriteTop + spriteHeight * markYOffset;
                    const [markR, markG, markB] = hslToRgb(levelTheme.enemyEyeHue, 80, 50);
                    ctx.fillStyle = `rgba(${markR}, ${markG}, ${markB}, ${0.3 * shade})`;
                    ctx.fillRect(spriteX, markY, SCALE + 1, markSize);
                }
            }
        }

        // Mark enemy as seen if any part was visible on screen
        if (visibleOnScreen && !enemy.seen) {
            enemy.seen = true;
            playEnemyRoarSound();
        }
    }
}

// Enemy shape function (returns height multiplier based on column position)
function getEnemyShape(t) {
    switch (levelTheme.enemyShape) {
        case 'humanoid':
            // Classic alien silhouette - shoulders, arms, thin legs
            if (t < 0.1 || t > 0.9) return 0.3; // Thin appendages
            if (t < 0.2 || t > 0.8) return 0.5; // Arms
            if (t < 0.3 || t > 0.7) return 0.75; // Shoulders
            return 0.85 + Math.sin(t * Math.PI) * 0.15; // Body/head bulge

        case 'blob':
            // Amorphous blob creature - round and wobbly
            const blobBase = Math.sin(t * Math.PI);
            const wobble = Math.sin(t * Math.PI * 6) * 0.08;
            return 0.3 + blobBase * 0.65 + wobble;

        case 'insectoid':
            // Spiky insect-like creature with angular features
            if (t < 0.05 || t > 0.95) return 0.6; // Antennae
            if (t < 0.15 || t > 0.85) return 0.25; // Thin neck/joints
            if (t < 0.25 || t > 0.75) return 0.7 + Math.abs(Math.sin(t * Math.PI * 4)) * 0.25; // Spiky limbs
            if (t < 0.35 || t > 0.65) return 0.5; // Thorax joints
            return 0.9 + Math.sin(t * Math.PI) * 0.1; // Central body

        case 'tall':
            // Tall, thin, elongated creature
            if (t < 0.15 || t > 0.85) return 0.15; // Very thin extremities
            if (t < 0.3 || t > 0.7) return 0.35; // Thin arms
            if (t < 0.4 || t > 0.6) return 0.55; // Narrow shoulders
            return 0.7 + Math.sin(t * Math.PI) * 0.25; // Elongated head/body

        case 'squat':
            // Short, wide, menacing creature
            if (t < 0.08 || t > 0.92) return 0.5; // Stubby limbs
            if (t < 0.2 || t > 0.8) return 0.75; // Wide arms
            if (t < 0.3 || t > 0.7) return 0.95; // Broad shoulders
            return 0.85 + Math.cos(t * Math.PI * 2) * 0.1; // Hulking body

        case 'spider':
            // Spider-like creature with multiple leg segments
            if (t < 0.1 || t > 0.9) return 0.7; // Outer legs (raised)
            if (t < 0.2 || t > 0.8) return 0.25; // Leg joints
            if (t < 0.3 || t > 0.7) return 0.6; // Inner legs
            if (t < 0.4 || t > 0.6) return 0.35; // Body connection
            return 0.8 + Math.sin(t * Math.PI) * 0.15; // Central body/head

        default:
            // Fallback to humanoid
            if (t < 0.1 || t > 0.9) return 0.3;
            if (t < 0.2 || t > 0.8) return 0.5;
            if (t < 0.3 || t > 0.7) return 0.75;
            return 0.85 + Math.sin(t * Math.PI) * 0.15;
    }
}

// Fire plasma ball (secondary fire - right click)
function firePlasmaBall() {
    if (currentWeapon !== 1) return; // Only works with plasma gun equipped
    if (plasmaballCooldown > 0) return;
    if (player.ammo < 10) {
        playEmptyClickSound();
        plasmaballCooldown = 15; // Brief cooldown to prevent click spam
        return;
    }

    player.ammo -= 10;
    plasmaballCooldown = 60; // 1 second cooldown
    playPlasmaBallSound();
    muzzleFlash = 1;

    plasmaBalls.push({
        x: player.x,
        y: player.y,
        angle: player.angle,
        speed: 0.15,
        radius: 0.4, // Collision radius for damaging enemies
        alive: true
    });
}

// Update plasma balls
function updatePlasmaBalls() {
    if (plasmaballCooldown > 0) plasmaballCooldown--;

    for (const ball of plasmaBalls) {
        if (!ball.alive) continue;

        // Move the ball
        ball.x += Math.cos(ball.angle) * ball.speed;
        ball.y += Math.sin(ball.angle) * ball.speed;

        // Check wall collision
        if (isWall(ball.x, ball.y)) {
            ball.alive = false;
            continue;
        }

        // Check enemy collisions
        let centerHit = false;
        for (const enemy of enemies) {
            if (!enemy.alive) continue;

            const dx = enemy.x - ball.x;
            const dy = enemy.y - ball.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Damage enemies within radius
            if (dist < ball.radius + 0.3) {
                enemy.health -= 30;
                if (enemy.health <= 0 && !enemy.dying) {
                    enemy.alive = false;
                    enemy.dying = true;
                    enemy.deathTimer = 0;
                    player.kills++;
                    playEnemyDeathSound();
                } else if (enemy.alive) {
                    playEnemyHitSound();
                }

                // Center hit - destroy the ball
                if (dist < 0.3) {
                    centerHit = true;
                }
            }
        }

        if (centerHit) {
            ball.alive = false;
        }
    }

    // Remove dead plasma balls
    for (let i = plasmaBalls.length - 1; i >= 0; i--) {
        if (!plasmaBalls[i].alive) {
            plasmaBalls.splice(i, 1);
        }
    }
}

// Attack function (handles both melee and ranged)
function attack() {
    if (shootCooldown > 0) return;

    if (currentWeapon === 0) {
        // Baton (melee) - one-hit kill, 3 second cooldown, short range
        shootCooldown = 180; // 3 seconds at 60fps
        swingAnimation = 20;
        playHammerSound();

        // Check if any enemy is in melee range
        const hitEnemy = enemies.find(enemy => {
            if (!enemy.alive) return false;

            const dx = enemy.x - player.x;
            const dy = enemy.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            let angle = Math.atan2(dy, dx) - player.angle;

            while (angle > Math.PI) angle -= 2 * Math.PI;
            while (angle < -Math.PI) angle += 2 * Math.PI;

            // Melee range: close distance, wider angle
            return dist < 1.5 && Math.abs(angle) < 0.5;
        });

        if (hitEnemy) {
            // Baton always one-hit kills regardless of enemy health
            hitEnemy.health = 0;
            hitEnemy.alive = false;
            hitEnemy.dying = true;
            hitEnemy.deathTimer = 0;
            player.kills++;
            playEnemyDeathSound();
        }
    } else {
        // Gun (ranged) - uses ammo
        if (player.ammo <= 0) {
            playEmptyClickSound();
            shootCooldown = 15; // Brief cooldown to prevent click spam
            return;
        }

        player.ammo--;
        shootCooldown = 15;
        muzzleFlash = 1;
        playGunSound();

        // Check if any enemy is in crosshairs
        const hitEnemy = enemies.find(enemy => {
            if (!enemy.alive) return false;

            const dx = enemy.x - player.x;
            const dy = enemy.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            let angle = Math.atan2(dy, dx) - player.angle;

            while (angle > Math.PI) angle -= 2 * Math.PI;
            while (angle < -Math.PI) angle += 2 * Math.PI;

            // Check if in crosshair and not behind wall
            const screenX = (0.5 + angle / FOV) * SCREEN_W;
            const col = Math.floor(screenX / SCALE);
            if (col < 0 || col >= NUM_RAYS) return false;

            return Math.abs(angle) < 0.1 && depthBuffer[col] >= dist;
        });

        if (hitEnemy) {
            hitEnemy.health -= 15;
            if (hitEnemy.health <= 0 && !hitEnemy.dying) {
                hitEnemy.alive = false;
                hitEnemy.dying = true;
                hitEnemy.deathTimer = 0;
                player.kills++;
                playEnemyDeathSound();
            } else {
                playEnemyHitSound();
            }
        }
    }
}

// Update enemies (AI)
function updateEnemies() {
    for (const enemy of enemies) {
        // Progress death animation
        if (enemy.dying) {
            enemy.deathTimer++;
            if (enemy.deathTimer >= 30) {
                enemy.dying = false; // Animation complete, fully dead
            }
            continue;
        }

        if (!enemy.alive) continue;
        if (!enemy.seen) continue; // Don't move until player has seen this enemy

        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // Move toward player if close enough
        if (dist < 10 && dist > 0.5) {
            const moveX = (dx / dist) * enemy.speed;
            const moveY = (dy / dist) * enemy.speed;

            const newX = enemy.x + moveX;
            const newY = enemy.y + moveY;

            if (!isWall(newX, enemy.y)) enemy.x = newX;
            if (!isWall(enemy.x, newY)) enemy.y = newY;
        }

        // Damage player if very close (max once per second per enemy)
        // Damage scales with level: 5 * currentLevel
        if (dist < 0.6) {
            const now = Date.now();
            if (!enemy.lastHitTime || now - enemy.lastHitTime >= 1000) {
                player.health -= 5 * currentLevel;
                headDamageFlash = 10;
                damageFlash = 1;
                playPlayerHitSound();
                enemy.lastHitTime = now;
            }
        }
    }
}

// Check for ammo box pickups
function checkAmmoPickups() {
    for (const box of ammoBoxes) {
        if (box.collected) continue;

        const dx = box.x - player.x;
        const dy = box.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 0.5) {
            box.collected = true;
            player.ammo += 15;
            playAmmoPickupSound();
        }
    }
}

// Check for health pack pickups
function checkHealthPickups() {
    for (const pack of healthPacks) {
        if (pack.collected) continue;
        if (player.health >= 100) continue; // Only pick up if damaged

        const dx = pack.x - player.x;
        const dy = pack.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 0.5) {
            pack.collected = true;
            player.health = Math.min(100, player.health + 25);
            playHealthPickupSound();
        }
    }
}

// Check for key pickup
function checkKeyPickup() {
    if (levelKey.collected || hasKey) return;

    const dx = levelKey.x - player.x;
    const dy = levelKey.y - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < 0.5) {
        levelKey.collected = true;
        hasKey = true;
        playKeyPickupSound();
    }
}

// Update UI (now handled by renderHUD)
function updateUI() {
    // HUD is now rendered on canvas
}

// Render minimap
function renderMinimap() {
    const scale = minimap.width / MAP_W;
    // Themed background
    const [bgR, bgG, bgB] = hslToRgb(levelTheme.wallHue, levelTheme.wallSat * 0.3, levelTheme.wallLight * 0.3);
    minimapCtx.fillStyle = `rgb(${bgR}, ${bgG}, ${bgB})`;
    minimapCtx.fillRect(0, 0, minimap.width, minimap.height);

    for (let y = 0; y < MAP_H; y++) {
        for (let x = 0; x < MAP_W; x++) {
            const tile = MAP[y][x];
            if (tile === 1) {
                // Spaceship walls - themed
                const [wr, wg, wb] = hslToRgb(levelTheme.wallHue, levelTheme.wallSat, levelTheme.wallLight * 1.5);
                minimapCtx.fillStyle = `rgb(${wr}, ${wg}, ${wb})`;
            } else if (tile === 2) {
                const door = getDoor(x, y);
                // Metallic door: themed when closed, fades when open
                const openness = door ? door.state : 0;
                const [dr, dg, db] = hslToRgb(levelTheme.doorHue, levelTheme.doorSat, levelTheme.doorLight * (1 - openness * 0.7));
                minimapCtx.fillStyle = `rgb(${dr},${dg},${db})`;
            } else if (tile === 3) {
                // Locked door: red when locked, green when player has key
                const door = getDoor(x, y);
                const openness = door ? door.state : 0;
                if (hasKey) {
                    const r = Math.floor(60 * (1 - openness) + 20 * openness);
                    const g = Math.floor(200 * (1 - openness) + 20 * openness);
                    const b = Math.floor(80 * (1 - openness) + 20 * openness);
                    minimapCtx.fillStyle = `rgb(${r},${g},${b})`;
                } else {
                    const r = Math.floor(200 * (1 - openness) + 20 * openness);
                    const g = Math.floor(60 * (1 - openness) + 20 * openness);
                    const b = Math.floor(40 * (1 - openness) + 20 * openness);
                    minimapCtx.fillStyle = `rgb(${r},${g},${b})`;
                }
            } else if (tile === 4) {
                // Exit portal: pulsing bright green
                const pulse = 0.7 + 0.3 * Math.sin(Date.now() * 0.005);
                const g = Math.floor(200 + 55 * pulse);
                minimapCtx.fillStyle = `rgb(50, ${g}, 100)`;
            } else {
                // Floor - themed dark
                const [fr, fg, fb] = hslToRgb(levelTheme.wallHue, levelTheme.wallSat * 0.4, levelTheme.wallLight * 0.5);
                minimapCtx.fillStyle = `rgb(${fr}, ${fg}, ${fb})`;
            }
            minimapCtx.fillRect(x * scale, y * scale, scale - 1, scale - 1);
        }
    }

    // Player - themed accent color
    const playerColor = `rgb(${levelTheme.lightR}, ${levelTheme.lightG}, ${levelTheme.lightB})`;
    minimapCtx.fillStyle = playerColor;
    minimapCtx.beginPath();
    minimapCtx.arc(player.x * scale, player.y * scale, 3, 0, Math.PI * 2);
    minimapCtx.fill();

    // Direction - themed accent color
    minimapCtx.strokeStyle = playerColor;
    minimapCtx.beginPath();
    minimapCtx.moveTo(player.x * scale, player.y * scale);
    minimapCtx.lineTo(
        player.x * scale + Math.cos(player.angle) * 15,
        player.y * scale + Math.sin(player.angle) * 15
    );
    minimapCtx.stroke();

    // Enemies - themed colors
    for (const enemy of enemies) {
        if (!enemy.alive && !enemy.dying) continue;
        // Fade out dying enemies
        const alpha = enemy.dying ? 1 - enemy.deathTimer / 30 : 1;
        const [er, eg, eb] = hslToRgb(levelTheme.enemyHue, levelTheme.enemySat, enemy.dying ? levelTheme.enemyLight * 0.5 : levelTheme.enemyLight * 1.5);
        minimapCtx.fillStyle = `rgba(${er}, ${eg}, ${eb}, ${alpha})`;
        minimapCtx.beginPath();
        minimapCtx.arc(enemy.x * scale, enemy.y * scale, 3, 0, Math.PI * 2);
        minimapCtx.fill();
    }

    // Ammo boxes - green
    for (const box of ammoBoxes) {
        if (box.collected) continue;
        minimapCtx.fillStyle = '#4f4';
        minimapCtx.fillRect(box.x * scale - 2, box.y * scale - 2, 4, 4);
    }

    // Health packs - red
    for (const pack of healthPacks) {
        if (pack.collected) continue;
        minimapCtx.fillStyle = '#f44';
        minimapCtx.fillRect(pack.x * scale - 2, pack.y * scale - 2, 4, 4);
    }

    // Key - golden (pulsing)
    if (!levelKey.collected) {
        const pulse = 0.7 + 0.3 * Math.sin(Date.now() * 0.008);
        minimapCtx.fillStyle = `rgb(255, ${Math.floor(200 * pulse)}, 50)`;
        minimapCtx.beginPath();
        minimapCtx.arc(levelKey.x * scale, levelKey.y * scale, 4, 0, Math.PI * 2);
        minimapCtx.fill();
    }
}

// Handle input
function handleInput() {
    // Mouse movement is applied directly in the mousemove event handler

    const cos = Math.cos(player.angle);
    const sin = Math.sin(player.angle);

    let newX = player.x;
    let newY = player.y;

    // Keyboard input
    if (keys['KeyW']) { newX += cos * player.speed; newY += sin * player.speed; }
    if (keys['KeyS']) { newX -= cos * player.speed; newY -= sin * player.speed; }
    if (keys['KeyA']) { newX += sin * player.speed; newY -= cos * player.speed; }
    if (keys['KeyD']) { newX -= sin * player.speed; newY += cos * player.speed; }
    if (keys['ArrowLeft']) rawMouseAngle -= player.rotSpeed / MOUSE_SENSITIVITY;
    if (keys['ArrowRight']) rawMouseAngle += player.rotSpeed / MOUSE_SENSITIVITY;
    player.angle = rawMouseAngle * MOUSE_SENSITIVITY;

    // Touch joystick input (forward/back is -dy, strafe is dx)
    if (touchState.move.active) {
        const jx = touchState.move.dx;
        const jy = -touchState.move.dy; // Invert Y so up = forward
        // Forward/backward
        newX += cos * player.speed * jy;
        newY += sin * player.speed * jy;
        // Strafe left/right
        newX -= sin * player.speed * jx;
        newY += cos * player.speed * jx;
    }

    // Touch look joystick input (continuous rotation based on joystick position)
    if (touchState.look.active && touchState.look.moved) {
        const lookSensitivity = 0.06; // Rotation speed multiplier
        rawMouseAngle += touchState.look.dx * lookSensitivity / MOUSE_SENSITIVITY;
        player.angle = rawMouseAngle * MOUSE_SENSITIVITY;
    }

    // Collision detection with sliding - check all four corners of player's collision box
    const margin = 0.25;

    // Check X movement (all 4 corners on the X axis)
    const canMoveX = !isWall(newX + margin, player.y + margin) &&
                     !isWall(newX + margin, player.y - margin) &&
                     !isWall(newX - margin, player.y + margin) &&
                     !isWall(newX - margin, player.y - margin);

    if (canMoveX) {
        player.x = newX;
    }

    // Check Y movement (all 4 corners on the Y axis, using updated X)
    const canMoveY = !isWall(player.x + margin, newY + margin) &&
                     !isWall(player.x + margin, newY - margin) &&
                     !isWall(player.x - margin, newY + margin) &&
                     !isWall(player.x - margin, newY - margin);

    if (canMoveY) {
        player.y = newY;
    }

    // Push player out if somehow stuck inside a wall
    if (isWall(player.x, player.y)) {
        // Find nearest open space
        for (let r = 1; r <= 3; r++) {
            for (let dy = -r; dy <= r; dy++) {
                for (let dx = -r; dx <= r; dx++) {
                    const testX = Math.floor(player.x) + dx + 0.5;
                    const testY = Math.floor(player.y) + dy + 0.5;
                    if (!isWall(testX, testY)) {
                        player.x = testX;
                        player.y = testY;
                        return;
                    }
                }
            }
        }
    }
}

// Game loop
function gameLoop(currentTime) {
    // Frame rate limiting
    const elapsed = currentTime - lastFrameTime;
    if (elapsed < FRAME_TIME) {
        requestAnimationFrame(gameLoop);
        return;
    }
    lastFrameTime = currentTime - (elapsed % FRAME_TIME); // Adjust for drift

    // Handle game over state
    if (player.health <= 0) {
        gameState = 'gameover';
    }

    // Handle victory state
    if (gameState === 'playing' && isInElevator()) {
        gameState = 'victory';
        playVictoryMusic();
    }

    // Show end screens
    if (gameState === 'gameover') {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);
        ctx.fillStyle = '#f00';
        ctx.font = '48px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', SCREEN_W / 2, SCREEN_H / 2 - 20);
        ctx.font = '24px monospace';
        ctx.fillStyle = '#fa0';
        ctx.fillText(`Level: ${currentLevel}`, SCREEN_W / 2, SCREEN_H / 2 + 20);
        ctx.fillStyle = '#f00';
        ctx.fillText(`Kills: ${player.kills}`, SCREEN_W / 2, SCREEN_H / 2 + 50);
        ctx.fillStyle = '#888';
        ctx.fillText('Press SPACE or click to restart', SCREEN_W / 2, SCREEN_H / 2 + 90);
        requestAnimationFrame(gameLoop);
        return;
    }

    if (gameState === 'victory') {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);
        ctx.fillStyle = '#0ff';
        ctx.font = '48px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`LEVEL ${currentLevel} COMPLETE!`, SCREEN_W / 2, SCREEN_H / 2 - 20);
        ctx.fillStyle = '#0f0';
        ctx.font = '24px monospace';
        ctx.fillText(`Kills: ${player.kills}`, SCREEN_W / 2, SCREEN_H / 2 + 25);
        ctx.fillStyle = '#fa0';
        ctx.fillText(`Health: ${Math.floor(player.health)} | Ammo: ${player.ammo}`, SCREEN_W / 2, SCREEN_H / 2 + 60);
        ctx.fillStyle = '#888';
        ctx.fillText('Press SPACE or click for next level', SCREEN_W / 2, SCREEN_H / 2 + 100);
        requestAnimationFrame(gameLoop);
        return;
    }

    handleInput();

    // Attack
    if (keys['Space']) attack();
    if (shootCooldown > 0) shootCooldown--;

    // Open doors
    if (keys['KeyE']) {
        tryOpenDoor();
        keys['KeyE'] = false; // Prevent holding E from spamming
    }

    updateDoors();
    updateEnemies();
    updatePlasmaBalls();
    checkAmmoPickups();
    checkHealthPickups();
    checkKeyPickup();
    render3D();
    renderMinimap();
    updateUI();

    requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
